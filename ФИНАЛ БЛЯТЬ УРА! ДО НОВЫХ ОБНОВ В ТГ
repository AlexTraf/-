import asyncio
from datetime import datetime, timedelta
import pytz
import sys
import os
from aiogram.types import BotCommand, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.filters.callback_data import CallbackData
from os import listdir, path, makedirs, rename
from telethon import TelegramClient, events, functions, types
from telethon.errors import ChannelPrivateError, FloodWaitError, ForbiddenError, UserNotParticipantError, UsernameOccupiedError
from telethon.tl.types import (
    ChannelParticipantBanned, ReactionEmoji,
    MessageEntityBold, MessageEntityItalic, MessageEntityUrl, MessageEntityTextUrl,
    MessageEntityMentionName, MessageEntityCode, MessageEntityPre,
    MessageEntityStrike, MessageEntityUnderline, MessageEntitySpoiler
)
from telethon.tl.types.messages import Messages
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.tl.functions.messages import ImportChatInviteRequest
from aiogram import Bot, Dispatcher, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram import types as atypes
import sqlite3
import logging
import random
import json
import tempfile
import shutil
from typing import Optional
import re
from telethon.tl.functions.stories import GetPeerStoriesRequest, ReadStoriesRequest, SendReactionRequest
# –õ–æ–≥–≥–µ—Ä
rootLogger = logging.getLogger('root')
rootLogger.setLevel(logging.DEBUG)
formatter = logging.Formatter('[%(asctime)s] [%(name)s] [%(levelname)s]: %(message)s (%(filename)s:%(lineno)d)')
fileHandler = logging.FileHandler("app.log", "w", encoding="utf-8")
fileHandler.setLevel(logging.DEBUG)
fileHandler.setFormatter(formatter)
rootLogger.addHandler(fileHandler)
consoleHandler = logging.StreamHandler(sys.stdout)
consoleHandler.setLevel(logging.INFO)
consoleHandler.setFormatter(formatter)
rootLogger.addHandler(consoleHandler)
FROZE_CHECK_BOT_USERNAME: str = "@vpilotnotifybot"
today = datetime.now().strftime("%Y-%m-%d")
daily_log_file = f"daily_log_{today}.txt"
dailyLogHandler = logging.FileHandler(daily_log_file, "a", encoding="utf-8")
dailyLogHandler.setLevel(logging.INFO)
dailyLogHandler.setFormatter(formatter)
rootLogger.addHandler(dailyLogHandler)
logging.getLogger('telethon').setLevel(logging.WARNING)
# –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
liking_tasks = []
company_stats = {}
stats_lock = asyncio.Lock()
chat_lock = asyncio.Lock()
company_active = {}
config = {}
with open("config.json", "r", encoding='utf-8') as config_file:
    config = json.load(config_file)
scheduler = AsyncIOScheduler()
bot = Bot(config["token"])
dp = Dispatcher()
owner_id = config["owner_id"]
chat_id = config["chat_id"]
default_company_config: dict = {}
sessions = []
selected_company = None
company_configs = {}
created_channels = {}
users_paused = {}
api_id = 28229033
api_hash = "00dda765bff2ad74e70cc0bb68eb6e6b"
POSITIVE_REACTIONS = ["‚ù§Ô∏è", "üëç", "üî•", "üòç", "üéâ"]
TRANS_TABLE = {
    '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'e', '–∂': 'zh',
    '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm', '–Ω': 'n', '–æ': 'o',
    '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u', '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts',
    '—á': 'ch', '—à': 'sh', '—â': 'sch', '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu',
    '—è': 'ya'
}
DEVICES_INFO = [
    {"model": "iPhone 13 Pro Max", "system_version": "18.2", "app_version": "11.2"},
    {"model": "iPhone XR", "system_version": "18.1", "app_version": "11.2"},
    {"model": "iPhone 16 Pro", "system_version": "17.2", "app_version": "11.2"}
]
# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
kb_menu = atypes.InlineKeyboardMarkup(inline_keyboard=[
    [atypes.InlineKeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å –¥–µ—Ç–∞–ª–∏ —Å–µ—Å—Å–∏–π", callback_data="change_sessions")],
    [atypes.InlineKeyboardButton(text="–í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∫–æ–º–ø–∞–Ω–∏—é", callback_data="change_company")],
    [atypes.InlineKeyboardButton(text="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="account_stats")],
    [atypes.InlineKeyboardButton(text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="check_account_status")],
    [atypes.InlineKeyboardButton(text="–û–±–Ω–æ–≤–∏—Ç—å —Å–µ—Å—Å–∏–∏", callback_data="refresh_sessions")],
    [atypes.InlineKeyboardButton(text="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –ª–∞–π–∫–∏–Ω–≥ —Å—Ç–æ—Ä–∏—Å", callback_data="toggle_story_liking")],
    [atypes.InlineKeyboardButton(text="–û—Ç–ø—Ä–∞–≤–∏—Ç—å –õ–°", callback_data="send_pm")]
])
kb_change_settings = atypes.InlineKeyboardMarkup(inline_keyboard=[
    [atypes.InlineKeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å –∏–º—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="change_fname")],
    [atypes.InlineKeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å –±–∏–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="change_bio")],
    [atypes.InlineKeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å —Ñ–∞–º–∏–ª–∏—é –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="change_lname")],
    [atypes.InlineKeyboardButton(text="–£–¥–∞–ª–∏—Ç—å —Ñ–æ—Ç–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="delete_avatar")],
    [atypes.InlineKeyboardButton(text="–ü–æ—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="change_avatar")],
    [atypes.InlineKeyboardButton(text="–î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª", callback_data="add_channel")],
    [atypes.InlineKeyboardButton(text="–°–æ–±—Ä–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤", callback_data="collect_created_views_stats")],
    [atypes.InlineKeyboardButton(text="–ò–∑–º–µ–Ω–∏—Ç—å —Ä–µ–∞–∫—Ü–∏–∏ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="change_story_reactions")],
    [atypes.InlineKeyboardButton(text="–§–∏–ª—å—Ç—Ä –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤", callback_data="filter_keywords")], # –î–æ–±–∞–≤–ª–µ–Ω–æ
    [atypes.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_menu")]
])
kb_company_config = atypes.InlineKeyboardMarkup(inline_keyboard=[
    [atypes.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_menu")]
])
kb_all_or_select = atypes.InlineKeyboardMarkup(inline_keyboard=[
    [atypes.InlineKeyboardButton(text="–í—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã", callback_data="select_all")],
    [atypes.InlineKeyboardButton(text="–í—ã–±—Ä–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã", callback_data="select_selective")],
    [atypes.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_channel")]
])
# –ö–ª–∞—Å—Å—ã —Å–æ—Å—Ç–æ—è–Ω–∏–π
class CompanyToggleState(StatesGroup):
    selected_companies = State()
class SetupParamsState(StatesGroup):
    waiting_value = State()
class BlacklistState(StatesGroup):
    company = State()
    usernames = State()
class SendPMState(StatesGroup):
    username = State()
    message = State()
class CompanyToggleCallback(CallbackData, prefix="company_toggle"):
    action: str
    company_name: str
class CollectViewsStatsState(StatesGroup):
    channel_name = State()
class CreateCompanyState(StatesGroup):
    name = State()
class AddPrivateChannelState(StatesGroup):
    name = State()
    avatar = State()
    posts = State()
    select = State()
    confirm = State()
class ChangeState(StatesGroup):
    change = State()
    value = State()
    select = State()
class KeywordsState(StatesGroup):
    waiting_keywords = State()
# –ö–ª–∞—Å—Å —Å–µ—Å—Å–∏–∏
class Session:
    def __init__(self, client, filename: str, company: str) -> None:
        self.app = client
        self.id = None
        self.me = None
        self.unblocked_at: datetime | None = None
        self.blocked = False
        self.sent_appelation = False
        self.filename = filename
        self.company = company
        self.limit = 0
        self.flood_wait_until: datetime | None = None
        self.rest_until: datetime | None = None
        self.story_likes_today = 0
        self.stopping = False
def init_db():
    conn = sqlite3.connect("database.db", check_same_thread=False)
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS channels (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            link TEXT NOT NULL UNIQUE,
            last_processed TIMESTAMP,
            status TEXT DEFAULT 'pending'
        )
    """)
    # –î–û–ë–ê–í–õ–Ø–ï–ú –ù–û–í–£–Æ –ö–û–õ–û–ù–ö–£, –ï–°–õ–ò –ï–Å –ù–ï–¢
    cursor.execute("PRAGMA table_info(channels)")
    columns = [col[1] for col in cursor.fetchall()]
    if 'current_processed' not in columns:
        cursor.execute("ALTER TABLE channels ADD COLUMN current_processed INTEGER DEFAULT 0")
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS processed_users (
            user_id INTEGER PRIMARY KEY,
            username TEXT,
            last_processed TIMESTAMP
        )
    """)
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS blacklist (
            username TEXT NOT NULL,
            company TEXT NOT NULL,
            PRIMARY KEY (username, company)
        )
    """)
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_channels_status ON channels(status)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_processed_users_last ON processed_users(last_processed)")
    cursor.execute("CREATE INDEX IF NOT EXISTS idx_blacklist_username_company ON blacklist(username, company)")
    conn.commit()
    return conn
conn = init_db()
def is_user_in_blacklist(username: str, company: str) -> bool:
    cursor = conn.cursor()
    cursor.execute("SELECT 1 FROM blacklist WHERE username = ? AND company = ?", (username, company))
    return cursor.fetchone() is not None
def load_channels_to_db(company):
    cursor = conn.cursor()
    total_channels = 0
   
    users_txt_path = f"./companies/{company}/channels.txt"
    if path.exists(users_txt_path):
        with open(users_txt_path, "r", encoding='utf-8') as users_file:
            channels = [line.strip() for line in users_file.read().replace("\r", "").replace("https://t.me/", "@").split("\n") if line.strip()]
            total_channels += len(channels)
            for channel in channels:
                cursor.execute("""
                    INSERT OR IGNORE INTO channels (link, status, last_processed, current_processed)
                    VALUES (?, 'pending', NULL, 0)
                """, (channel,))
    users_sub_txt_path = f"./companies/{company}/channels_sub.txt"
    if path.exists(users_sub_txt_path):
        with open(users_sub_txt_path, "r", encoding='utf-8') as users_sub_file:
            channels = [line.strip() for line in users_sub_file.read().replace("\r", "").replace("https://t.me/", "@").split("\n") if line.strip()]
            total_channels += len(channels)
            for channel in channels:
                cursor.execute("""
                    INSERT OR IGNORE INTO channels (link, status, last_processed, current_processed)
                    VALUES (?, 'processed', ?, 0)
                """, (channel, datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S.%f")))
    # –°–±—Ä–æ—Å current_processed –¥–ª—è –≤—Å–µ—Ö processed –∫–∞–Ω–∞–ª–æ–≤
    cursor.execute("UPDATE channels SET current_processed = 0 WHERE status = 'processed'")
   
    conn.commit()
    rootLogger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {total_channels} –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company} –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö")
with open(f"proxies.txt", "r", encoding='utf-8') as proxy_file:
    global proxies
    proxy_content = proxy_file.read().replace("\r", "")
    proxies = list(map(lambda x: ("http", *x.split(":")), proxy_content.split("\n")))
for company_path in listdir("./companies"):
    if path.exists(f"./companies/{company_path}/config.json"):
        with open(f"./companies/{company_path}/config.json", "r", encoding='utf-8') as config_file:
            company_configs[company_path] = json.load(config_file)
    else:
        company_configs[company_path] = default_company_config
    # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
    if 'like_probability' not in company_configs[company_path]:
        company_configs[company_path]['like_probability'] = 0.8
    if 'accounts_per_channel' not in company_configs[company_path]:
        company_configs[company_path]['accounts_per_channel'] = 1
    if 'story_delay_min' not in company_configs[company_path]:
        company_configs[company_path]['story_delay_min'] = 1.0
    if 'story_delay_max' not in company_configs[company_path]:
        company_configs[company_path]['story_delay_max'] = 2.0
    if 'likes_per_break' not in company_configs[company_path]:
        company_configs[company_path]['likes_per_break'] = 50
    if 'break_seconds' not in company_configs[company_path]:
        company_configs[company_path]['break_seconds'] = 100
for company_path in listdir("./companies"):
    company_stats[company_path] = {
        "stories_viewed": 0,
        "likes_set": 0,
        "unique_users": set(),
        "channels_processed": 0,
        "chats_processed": 0,
        "unique_users_with_stories": set()
    }
    stats_file = f"./companies/{company_path}/company_stats.json"
    if os.path.exists(stats_file):
        with open(stats_file, "r", encoding='utf-8') as f:
            stats = json.load(f)
            company_stats[company_path] = {
                "stories_viewed": stats["stories_viewed"],
                "likes_set": stats["likes_set"],
                "unique_users": set(stats["unique_users"]),
                "channels_processed": stats["channels_processed"],
                "chats_processed": stats["chats_processed"],
                "unique_users_with_stories": set(stats.get("unique_users_with_stories", []))
            }
        rootLogger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company_path} –∏–∑ {stats_file}")
    else:
        rootLogger.info(f"–§–∞–π–ª —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company_path} –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å –Ω—É–ª—è")
    load_channels_to_db(company_path)
def save_stats(company):
    stats = company_stats.get(company, {
        "stories_viewed": 0,
        "likes_set": 0,
        "unique_users": set(),
        "channels_processed": 0,
        "chats_processed": 0,
        "unique_users_with_stories": set()
    })
    stats_file = f"./companies/{company}/company_stats.json"
    try:
        data_to_save = {
            "stories_viewed": stats["stories_viewed"],
            "likes_set": stats["likes_set"],
            "unique_users": list(stats["unique_users"]),
            "channels_processed": stats["channels_processed"],
            "chats_processed": stats["chats_processed"],
            "unique_users_with_stories": list(stats["unique_users_with_stories"])
        }
        rootLogger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–ª—è {company}: "
                       f"stories_viewed={stats['stories_viewed']}, "
                       f"likes_set={stats['likes_set']}, "
                       f"unique_users_count={len(stats['unique_users'])}, "
                       f"unique_users_with_stories={len(stats['unique_users_with_stories'])}, "
                       f"channels_processed={stats['channels_processed']}, "
                       f"chats_processed={stats['chats_processed']}")
        with open(stats_file, "w", encoding='utf-8') as f:
            json.dump(data_to_save, f, ensure_ascii=False)
        rootLogger.info(f"–£—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–ª—è {company} –≤ {stats_file}")
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–ª—è {company}: {str(e)}")
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "back_to_channel"))
async def back_to_channel(callback: atypes.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:", reply_markup=kb_change_settings)
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "show_stats"))
async def handle_show_stats(callback: atypes.CallbackQuery):
    await show_stats(callback)
async def show_stats(callback: atypes.CallbackQuery):
    global selected_company
    if selected_company is None:
        await callback.message.edit_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é!")
        return
    stats_text = get_stats_text(selected_company) # –£–±—Ä–∞–ª replace, —Ç–∞–∫ –∫–∞–∫ –∑–∞–≥–æ–ª–æ–≤–æ–∫ —É–∂–µ –≤–Ω—É—Ç—Ä–∏
    await callback.message.edit_text(stats_text)
    await callback.answer()
def write_daily_log(message):
    today = datetime.now().strftime("%Y-%m-%d")
    log_file = f"daily_log_{today}.txt"
    with open(log_file, "a", encoding="utf-8") as f:
        f.write(f"[{datetime.now().strftime('%H:%M:%S')}] {message}\n")
def get_stats_text(company):
    stats = company_stats.get(company, {
        "stories_viewed": 0,
        "likes_set": 0,
        "unique_users": set(),
        "channels_processed": 0,
        "chats_processed": 0,
        "unique_users_with_stories": set()
    })
    return (
        f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–ª—è {company}:\n" # –î–æ–±–∞–≤–ª–µ–Ω–æ
        f"–°—Ç–æ—Ä–∏—Å –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ: {stats['stories_viewed']}\n"
        f"–õ–∞–π–∫–æ–≤ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {stats['likes_set']}\n"
        f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –æ—Ç–∫—Ä—ã—Ç–æ: {len(stats['unique_users'])}\n"
        f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–æ —Å—Ç–æ—Ä–∏—Å–∞–º–∏: {len(stats['unique_users_with_stories'])}\n"
        f"–ö–∞–Ω–∞–ª–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: {stats['channels_processed']}\n"
        f"–ß–∞—Ç–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: {stats['chats_processed']}\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:"
    )
def get_all_stats():
    stats = []
    total_accounts = 0
    for company in company_configs.keys():
        company_sessions = list(filter(lambda x: x.me is not None and x.company == company, sessions))
        company_deactivated = list(filter(lambda x: x.me is None and x.company == company, sessions))
        accounts_count = len(company_sessions) + len(company_deactivated)
        stats.append(f"–ö–æ–º–ø–∞–Ω–∏—è: {company}")
        stats.append(f"–ê–∫–∫–∞—É–Ω—Ç–æ–≤: {accounts_count}")
        stats.append(f"–õ–∞–π–∫–æ–≤ —Å—Ç–æ—Ä–∏—Å —Å–µ–≥–æ–¥–Ω—è: {sum(s.story_likes_today for s in company_sessions)}")
        stats.append(f"–°—Ç–æ—Ä–∏—Å –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ: {company_stats[company]['stories_viewed']}")
        stats.append(f"–õ–∞–π–∫–æ–≤ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {company_stats[company]['likes_set']}")
        stats.append(f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –æ—Ç–∫—Ä—ã—Ç–æ: {len(company_stats[company]['unique_users'])}")
        stats.append(f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–æ —Å—Ç–æ—Ä–∏—Å–∞–º–∏: {len(company_stats[company]['unique_users_with_stories'])}") # –ù–æ–≤—ã–π —Å—á—ë—Ç—á–∏–∫
        stats.append(f"–ö–∞–Ω–∞–ª–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: {company_stats[company]['channels_processed']}")
        stats.append(f"–ß–∞—Ç–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: {company_stats[company]['chats_processed']}")
        stats.append("")
        total_accounts += accounts_count
    stats.append("–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–º –∫–æ–º–ø–∞–Ω–∏—è–º:")
    stats.append(f"–ê–∫–∫–∞—É–Ω—Ç–æ–≤: {total_accounts}")
    stats.append(f"–õ–∞–π–∫–æ–≤ —Å—Ç–æ—Ä–∏—Å —Å–µ–≥–æ–¥–Ω—è: {sum(s.story_likes_today for s in sessions if s.me)}")
    stats.append(f"–°—Ç–æ—Ä–∏—Å –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ: {sum(company_stats[company]['stories_viewed'] for company in company_stats)}")
    stats.append(f"–õ–∞–π–∫–æ–≤ –ø–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {sum(company_stats[company]['likes_set'] for company in company_stats)}")
    stats.append(f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –æ—Ç–∫—Ä—ã—Ç–æ: {len(set.union(*(company_stats[company]['unique_users'] for company in company_stats)))}")
    stats.append(f"–£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å–æ —Å—Ç–æ—Ä–∏—Å–∞–º–∏: {len(set.union(*(company_stats[company]['unique_users_with_stories'] for company in company_stats)))}") # –ù–æ–≤—ã–π —Å—á—ë—Ç—á–∏–∫
    stats.append(f"–ö–∞–Ω–∞–ª–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: {sum(company_stats[company]['channels_processed'] for company in company_stats)}")
    stats.append(f"–ß–∞—Ç–æ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: {sum(company_stats[company]['chats_processed'] for company in company_stats)}")
    return "\n".join(stats)
def transliterate(text):
    result = ''
    for char in text.lower():
        result += TRANS_TABLE.get(char, char)
    return ''.join(c for c in result if c.isalpha() or c.isspace()).replace(" ", "")
def make_client(session) -> TelegramClient:
    proxy = random.choice(proxies) if proxies else None
    device = random.choice(DEVICES_INFO) if 'DEVICES_INFO' in globals() else {"model": "iPhone 13 Pro Max", "system_version": "18.2", "app_version": "11.2"}
    client = TelegramClient(
        session=session,
        api_id=api_id,
        api_hash=api_hash,
        proxy=proxy,
        device_model=device["model"],
        system_version=device["system_version"],
        app_version=device["app_version"],
        lang_code="ru",
        system_lang_code="ru-RU"
    )
    log_msg = f"–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –¥–ª—è —Å–µ—Å—Å–∏–∏: {session}"
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    # Event handlers (—Ñ–∏–∫—Å: —Ç–æ–ª—å–∫–æ –ø—Ä–∏–≤–∞—Ç—ã –æ—Ç –ª—é–¥–µ–π, –±–µ–∑ —Å–ø–∞–º–∞ —Å—Ç–∞—Ç—É—Å–æ–≤)
    @client.on(events.NewMessage)
    async def handle_new_message(event):
        if not event.is_private: # –¢–æ–ª—å–∫–æ –ø—Ä–∏–≤–∞—Ç—ã, –∏–≥–Ω–æ—Ä –∫–∞–Ω–∞–ª—ã/–≥—Ä—É–ø–ø—ã
            return
        sender = await event.get_sender()
        if not isinstance(sender, types.User): # –¢–æ–ª—å–∫–æ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            return
        me = await client.get_me() # –ü–æ–ª—É—á–∞–µ–º me –¥–ª—è session
        session = next((s for s in sessions if s.me and s.me.id == me.id), None)
        if not session:
            return # –ù–µ—Ç session ‚Äî –ø—Ä–æ–ø—É—Å–∫
        chat = await event.get_chat() # –î–ª—è –ø—Ä–∏–≤–∞—Ç ‚Äî User
        chat_name = sender.first_name or "Unnamed User" # –î–ª—è User ‚Äî first_name
        sender_name = sender.username or sender.first_name or str(sender.id)
        msg_text = event.message.message
        if msg_text: # –¢–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç, –Ω–µ media
            rootLogger.info(f"–ù–æ–≤–æ–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {sender_name}: {msg_text}")
            write_daily_log(f"–ù–æ–≤–æ–µ –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç {sender_name}: {msg_text}")
            # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ owner_id
            try:
                notify_msg = f"{session.filename} - {session.company}\n–û—Ç @{sender_name}: {msg_text}"
                await bot.send_message(owner_id, notify_msg)
            except FloodWaitError as e:
                rootLogger.warning(f"FloodWait –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ owner_id: {e.seconds}s")
                await asyncio.sleep(e.seconds)
            except Exception as e:
                rootLogger.error(f"–û—à–∏–±–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è owner_id: {e}")
   
    # UserUpdate: –î–æ–±–∞–≤—å cooldown, —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å (dict per client)
    status_cooldown = {} # {user_id: last_log_time}
    @client.on(events.UserUpdate)
    async def handle_user_update(event):
        user_id = event.user_id
        now = datetime.now()
        if user_id in status_cooldown and (now - status_cooldown[user_id]).seconds < 300: # 5 –º–∏–Ω cooldown
            return
        status_cooldown[user_id] = now
        try:
            user = await client.get_entity(user_id)
            user_name = user.username or user.first_name or str(user_id)
            status = "–æ–Ω–ª–∞–π–Ω" if hasattr(event, 'status') and event.status else "–æ—Ñ—Ñ–ª–∞–π–Ω" # –§–∏–∫—Å: check hasattr
            rootLogger.info(f"–°—Ç–∞—Ç—É—Å {user_name}: {status}")
            write_daily_log(f"–°—Ç–∞—Ç—É—Å {user_name}: {status}")
        except:
            rootLogger.info(f"–°—Ç–∞—Ç—É—Å {user_id}: {'–æ–Ω–ª–∞–π–Ω' if hasattr(event, 'status') and event.status else '–æ—Ñ—Ñ–ª–∞–π–Ω'}")
   
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –¥–ª—è @spambot
    client.add_event_handler(on_spambot_message, events.NewMessage(chats="@spambot"))
    client.add_event_handler(on_spambot_message, events.NewMessage(chats=178220800))
    return client
async def switch_company(callback: atypes.CallbackQuery, company: str):
    global selected_company
    selected_company = company
    stats_file = f"./companies/{company}/company_stats.json"
    if os.path.exists(stats_file):
        with open(stats_file, "r", encoding='utf-8') as f:
            stats = json.load(f)
            company_stats[company] = {
                "stories_viewed": stats.get("stories_viewed", 0),
                "likes_set": stats.get("likes_set", 0),
                "unique_users": set(stats.get("unique_users", [])),
                "channels_processed": stats.get("channels_processed", 0),
                "chats_processed": stats.get("chats_processed", 0),
                "unique_users_with_stories": set(stats.get("unique_users_with_stories", []))
            }
    else:
        company_stats[company] = {
            "stories_viewed": 0,
            "likes_set": 0,
            "unique_users": set(),
            "channels_processed": 0,
            "chats_processed": 0,
            "unique_users_with_stories": set()
        }
    await callback.message.edit_text(f"–í—ã –ø–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –Ω–∞ –∫–æ–º–ø–∞–Ω–∏—é: {company}")
    await callback.answer()
async def reconnect_session(session):
    try:
        if session.app.is_connected():
            await session.app.disconnect()
        await session.app.connect()
        rootLogger.info(f"–°–µ—Å—Å–∏—è {session.filename} —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∞")
        return True
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}")
        return False
async def determine_chat_type(session, chat_id):
    try:
        participants_count = (await session.app(functions.channels.GetFullChannelRequest(chat_id))).full_chat.participants_count
        return "open" if participants_count > 50 else "closed"
    except Exception as e:
        rootLogger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø —á–∞—Ç–∞ {chat_id}: {str(e)}")
        return "closed"
async def parse_open_chat(session, chat_id):
    users = []
    try:
        async for participant in session.app.iter_participants(chat_id):
            if hasattr(participant, 'user') and participant.user and participant.user.id:
                users.append(participant.user.id)
        users = list(set(users))
        rootLogger.info(f"–°–æ–±—Ä–∞–Ω–æ {len(users)} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ —á–∞—Ç–∞ {chat_id}")
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–∫—Ä—ã—Ç–æ–≥–æ —á–∞—Ç–∞ {chat_id}: {str(e)}")
    return users
async def parse_closed_chat(session, chat_id):
    users = set()
    try:
        async for message in session.app.iter_messages(chat_id):
            try:
                if message.from_id and isinstance(message.from_id, types.PeerUser):
                    users.add(message.from_id.user_id)
            except Exception as e:
                rootLogger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç–µ {chat_id}: {str(e)}")
                continue
        rootLogger.info(f"–°–æ–±—Ä–∞–Ω–æ {len(users)} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ —á–∞—Ç–∞ {chat_id}")
    except FloodWaitError as e:
        rootLogger.warning(f"FloodWait –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ —á–∞—Ç–∞ {chat_id}: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥")
        await asyncio.sleep(e.seconds)
        return await parse_closed_chat(session, chat_id)
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∑–∞–∫—Ä—ã—Ç–æ–≥–æ —á–∞—Ç–∞ {chat_id}: {str(e)}")
    return list(users)
async def process_channel(session, channel_id):
    try:
        channel = await session.app.get_entity(channel_id)
        full_channel = await session.app(functions.channels.GetFullChannelRequest(channel))
        linked_chat_id = full_channel.full_chat.linked_chat_id
        if linked_chat_id:
            chat_type = await determine_chat_type(session, linked_chat_id)
            users = await parse_open_chat(session, linked_chat_id) if chat_type == "open" else await parse_closed_chat(session, linked_chat_id)
            return users
        else:
            rootLogger.info(f"–ö–∞–Ω–∞–ª {channel_id} –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω–Ω–æ–≥–æ —á–∞—Ç–∞")
            return []
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–∞–Ω–∞–ª–∞ {channel_id}: {str(e)}")
        return []
async def process_user_stories(session, user_id):
    company = session.company
    cursor = conn.cursor()
    cursor.execute("""
        SELECT last_processed
        FROM processed_users
        WHERE user_id = ?
    """, (user_id,))
    result = cursor.fetchone()
    if result and result[0]:
        last_processed = datetime.strptime(result[0], "%Y-%m-%d %H:%M:%S.%f")
        last_processed = last_processed.replace(tzinfo=pytz.UTC)
        if (datetime.now(pytz.UTC) - last_processed).total_seconds() < 24 * 3600:
            rootLogger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –º–µ–Ω–µ–µ 24 —á–∞—Å–æ–≤ –Ω–∞–∑–∞–¥, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
            return
    try:
        try:
            user = await session.app.get_entity(user_id)
            peer = await session.app.get_input_entity(user)
        except ValueError:
            return
        user_display = f"@{user.username}" if user.username else f"ID {user_id}"
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫
        if user.username and is_user_in_blacklist(user.username, company):
            rootLogger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_display} –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —á—ë—Ä–Ω–æ–º —Å–ø–∏—Å–∫–µ –∫–æ–º–ø–∞–Ω–∏–∏ {company}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
            return
        async with stats_lock:
            company_stats[company]["unique_users"].add(user_id)
            rootLogger.info(f"–î–æ–±–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_display} –≤ unique_users –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company}, –≤—Å–µ–≥–æ: {len(company_stats[company]['unique_users'])}")
       
        # –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
        keywords = company_configs[company].get('keywords', [])
        if keywords:
            full_user = await session.app(functions.users.GetFullUserRequest(id=user))
            user_info = (full_user.users[0].first_name or '' + ' ' + full_user.users[0].last_name or '' + ' ' + full_user.full_user.about or '').lower()
            if not any(kw in user_info for kw in keywords):
                rootLogger.info(f"–ü—Ä–æ–ø—É—Å–∫ {user_display}: –Ω–µ—Ç –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –≤ –ø—Ä–æ—Ñ–∏–ª–µ")
                write_daily_log(f"–ü—Ä–æ–ø—É—Å–∫ {user_display}: –Ω–µ—Ç –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –≤ –ø—Ä–æ—Ñ–∏–ª–µ")
                return
       
        peer_stories = await session.app(GetPeerStoriesRequest(peer=peer))
        if not peer_stories.stories or not peer_stories.stories.stories:
            rootLogger.info(f"–£ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_display} –Ω–µ—Ç —Å—Ç–æ—Ä–∏—Å")
            cursor.execute("""
                INSERT OR REPLACE INTO processed_users (user_id, username, last_processed)
                VALUES (?, ?, ?)
            """, (user_id, user.username, datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S.%f")))
            conn.commit()
            return
       
        stories = peer_stories.stories.stories
        rootLogger.info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_display} –∏–º–µ–µ—Ç {len(stories)} —Å—Ç–æ—Ä–∏—Å")
       
        async with stats_lock:
            company_stats[company]["unique_users_with_stories"].add(user_id)
            rootLogger.info(f"–î–æ–±–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_display} –≤ unique_users_with_stories –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company}, –≤—Å–µ–≥–æ: {len(company_stats[company]['unique_users_with_stories'])}")
       
        for story in stories:
            try:
                await session.app(ReadStoriesRequest(peer=peer, max_id=story.id))
                rootLogger.info(f"–°—Ç–æ—Ä–∏—Å {story.id} –æ—Ç {user_display} –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞")
                log_message = f"–ê–∫–∫–∞—É–Ω—Ç {session.filename} (–∫–æ–º–ø–∞–Ω–∏—è {company}) –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–ª —Å—Ç–æ—Ä–∏—Å {story.id} —É {user_display}"
                rootLogger.info(log_message)
                write_daily_log(log_message)
               
                async with stats_lock:
                    company_stats[company]["stories_viewed"] += 1
               
                like_prob = company_configs[company].get('like_probability', 0.8)
                if random.random() < like_prob:
                    likes_per_break = company_configs[company].get('likes_per_break', 50)
                    break_seconds = company_configs[company].get('break_seconds', 100)
                    if company_stats[company]["likes_set"] % likes_per_break == 0:
                        await asyncio.sleep(break_seconds)
                    reaction = random.choice(POSITIVE_REACTIONS)
                    await session.app(SendReactionRequest(
                        peer=peer,
                        story_id=story.id,
                        reaction=ReactionEmoji(emoticon=reaction)
                    ))
                    rootLogger.info(f"–õ–∞–π–∫–Ω—É—Ç–∞ —Å—Ç–æ—Ä–∏—Å {story.id} –æ—Ç {user_display} —Å {reaction}")
                    log_message = f"–ê–∫–∫–∞—É–Ω—Ç {session.filename} (–∫–æ–º–ø–∞–Ω–∏—è {company}) –ª–∞–π–∫–Ω—É–ª —Å—Ç–æ—Ä–∏—Å {story.id} —É {user_display} —Å {reaction}"
                    rootLogger.info(log_message)
                    write_daily_log(log_message)
                    async with stats_lock:
                        company_stats[company]["likes_set"] += 1
                      
                else:
                    rootLogger.info(f"–°—Ç–æ—Ä–∏—Å {story.id} –æ—Ç {user_display} –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞")
                    log_message = f"–°—Ç–æ—Ä–∏—Å {story.id} –æ—Ç {user_display} –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–∞"
                    rootLogger.info(log_message)
                    write_daily_log(log_message)
              
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å—Ç–æ—Ä–∏—Å –∏–∑ config
                story_delay_min = company_configs[company].get('story_delay_min', 1.0)
                story_delay_max = company_configs[company].get('story_delay_max', 2.0)
                await asyncio.sleep(random.uniform(story_delay_min, story_delay_max))
            except FloodWaitError as e:
                log_msg = f"FloodWait –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç–æ—Ä–∏—Å {story.id} –æ—Ç {user_display}: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥"
                rootLogger.warning(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
                await asyncio.sleep(e.seconds)
                continue
            except Exception as e:
                rootLogger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç–æ—Ä–∏—Å {story.id} –æ—Ç {user_display}: {str(e)}")
                continue
        cursor.execute("""
            INSERT OR REPLACE INTO processed_users (user_id, username, last_processed)
            VALUES (?, ?, ?)
        """, (user_id, user.username if user.username else None, datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S.%f")))
        conn.commit()
    except FloodWaitError as e:
        log_msg = f"FloodWait –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–æ—Ä–∏—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_display}: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥"
        rootLogger.warning(log_msg)
        write_daily_log(log_msg)
        await bot.send_message(chat_id, log_msg)
        await asyncio.sleep(e.seconds)
        return await process_user_stories(session, user_id)
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç–æ—Ä–∏—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_display}: {str(e)}")

async def copy_channel_data(session: Session, link: str) -> Optional[dict]:
    """–ö–æ–ø–∏—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª–∞ –ø–æ —Å—Å—ã–ª–∫–µ (name, avatar bytes, posts). –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç dict –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ."""
    try:
        # –ü–∞—Ä—Å–∏–Ω–≥ —Å—Å—ã–ª–∫–∏ (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ @username, t.me/username, https://t.me/username)
        link_match = re.match(r'(?:https?://t\.me/|t\.me/|@)?([a-zA-Z0-9_]+)', link)
        if not link_match:
            rootLogger.error(f"–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞: {link}")
            return None
        username = link_match.group(1)
        entity = await session.app.get_entity(username)
        if not isinstance(entity, types.Channel):
            rootLogger.error(f"–≠—Ç–æ –Ω–µ –∫–∞–Ω–∞–ª: {link}")
            return None
        # –ù–∞–∑–≤–∞–Ω–∏–µ –∏ –æ–ø–∏—Å–∞–Ω–∏–µ
        full_channel = await session.app(functions.channels.GetFullChannelRequest(entity))
        name = entity.title
        about = full_channel.full_chat.about or "" # –ù–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Å–æ–∑–¥–∞–Ω–∏–∏, –Ω–æ –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã
        # –ê–≤–∞—Ç–∞—Ä (bytes, –µ—Å–ª–∏ –µ—Å—Ç—å) ‚Äî —Ñ–∏–∫—Å: –¥–ª—è –∫–∞–Ω–∞–ª–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º iter_profile_photos
        avatar_bytes = None
        try:
            async for photo in session.app.iter_profile_photos(entity, limit=1):
                avatar_bytes = await session.app.download_media(photo) # Bytes –Ω–∞–ø—Ä—è–º—É—é
                break
        except Exception as e:
            rootLogger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å –∞–≤–∞—Ç–∞—Ä –¥–ª—è {link}: {str(e)}")
        # –ü–æ—Å—Ç—ã (iter_messages, reverse=True –¥–ª—è —Å—Ç–∞—Ä—ã—Ö —Å–Ω–∞—á–∞–ª–∞; –ª–∏–º–∏—Ç 50)
        posts = []
        media_groups = {}
        async for msg in session.app.iter_messages(entity, reverse=True, limit=50):
            if isinstance(msg, types.MessageService): # –§–∏–∫—Å: –ø—Ä–æ–ø—É—Å–∫–∞–µ–º service messages
                continue
            if msg.grouped_id:
                if msg.grouped_id not in media_groups:
                    media_groups[msg.grouped_id] = []
                media_groups[msg.grouped_id].append({
                    'type': msg.media.__class__.__name__.lower() if msg.media else 'photo',
                    'caption': msg.message or '',
                    'entities': msg.entities or []
                })
                if len(media_groups[msg.grouped_id]) == 1:
                    posts.append({'type': 'album', 'photos': media_groups[msg.grouped_id]})
            elif msg.message:
                posts.append({'type': 'text', 'content': msg.message, 'entities': msg.entities or []})
            elif msg.media:
                try:
                    media_bytes = await session.app.download_media(msg.media) # Bytes –¥–ª—è copy
                    posts.append({
                        'type': msg.media.__class__.__name__.lower(),
                        'caption': msg.message or '',
                        'entities': msg.entities or [],
                        'media_bytes': media_bytes
                    })
                except Exception as e:
                    rootLogger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å media –¥–ª—è –ø–æ—Å—Ç–∞ –≤ {link}: {str(e)}")
                    continue
        rootLogger.info(f"–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –¥–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª–∞ {link}: –Ω–∞–∑–≤–∞–Ω–∏–µ '{name}', {len(posts)} –ø–æ—Å—Ç–æ–≤, –∞–≤–∞—Ç–∞—Ä {'–¥–∞' if avatar_bytes else '–Ω–µ—Ç'}")
        write_daily_log(f"–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –¥–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª–∞ {link}: –Ω–∞–∑–≤–∞–Ω–∏–µ '{name}', {len(posts)} –ø–æ—Å—Ç–æ–≤")
        return {
            'name': name,
            'about': about,
            'avatar': avatar_bytes, # Bytes –¥–ª—è upload
            'posts': posts
        }
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ {link}: {str(e)}")
        write_daily_log(f"–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ {link}: {str(e)}")
        return None
async def create_channel_for_accounts(data, message, state: FSMContext):
    name = data.get("name")
    avatar = data.get("avatar")
    posts = data.get("posts", [])
    select = data.get("select", [])
    ses = [s for s in sessions if s.me and int(s.me.id) in select]
    if not ses:
        await message.edit_text("–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞.")
        await state.clear()
        await start(message)
        return
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º created_channels –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏, –µ—Å–ª–∏ –Ω–µ—Ç (—Ñ–∏–∫—Å KeyError)
    if selected_company not in created_channels:
        created_channels[selected_company] = []
    
    created_count = 0  # –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ (—Å–æ–∑–¥–∞–Ω–∏—è + –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
    failed_sessions = []  # –î–ª—è –æ—à–∏–±–æ–∫ —Å retry
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äî —Ä–µ–ø–æ—Å—Ç –ø–æ—Å—Ç–æ–≤ + –∞–≤–∞—Ç–∞—Ä/–Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö
    if not posts:
        log_msg = f"–†–µ–ø–æ—Å—Ç –ø–æ—Å—Ç–æ–≤ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞/–Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤ (–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ)"
        rootLogger.info(log_msg)
        write_daily_log(log_msg)
        for session in ses:
            try:
                full_user = await session.app(functions.users.GetFullUserRequest(id=session.me.id))
                channel_id = full_user.full_user.personal_channel_id
                if channel_id:
                    channel_peer = types.PeerChannel(channel_id)
                    channel_entity = await session.app.get_entity(channel_peer)
                    # –ù–∞–∑–≤–∞–Ω–∏–µ
                    if channel_entity.title != name:
                        await session.app(functions.channels.EditTitleRequest(channel=channel_entity, title=name))
                        log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ '{name}' –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    # –ê–≤–∞—Ç–∞—Ä (–±–µ–∑ —Å–∂–∞—Ç–∏—è)
                    if avatar:
                        if isinstance(avatar, str):  # file_id from bot
                            file_info = await bot.get_file(avatar)
                            photo_bytes = await bot.download_file(file_info.file_path)
                        else:
                            photo_bytes = avatar
                        file = await session.app.upload_file(photo_bytes, file_name="avatar.jpg")
                        await session.app(functions.channels.EditPhotoRequest(channel=channel_entity, photo=file))
                        log_msg = f"–ê–≤–∞—Ç–∞—Ä –∫–∞–Ω–∞–ª–∞ {channel_id} –æ–±–Ω–æ–≤–ª—ë–Ω –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ø–æ—Å—Ç–æ–≤
                    async for msg in session.app.iter_messages(channel_id):
                        await session.app.delete_messages(channel_id, [msg.id])
                    log_msg = f"–°—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã —É–¥–∞–ª–µ–Ω—ã –∏–∑ {channel_id} –¥–ª—è {session.filename}"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
                    # –†–µ–ø–æ—Å—Ç –ø–æ—Å—Ç–æ–≤
                    donor_entity = await session.app.get_entity(data['link'])  # link —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ state
                    message_ids = []
                    async for msg in session.app.iter_messages(donor_entity, limit=50):
                        if not isinstance(msg, types.MessageService):
                            message_ids.append(msg.id)
                    if message_ids:
                        forwarded = await session.app.forward_messages(channel_peer, message_ids, donor_entity)
                        log_msg = f"–†–µ–ø–æ—Å—Ç {len(forwarded)} –ø–æ—Å—Ç–æ–≤ –≤ {channel_id} –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    else:
                        log_msg = f"–ö–∞–Ω–∞–ª-–¥–æ–Ω–æ—Ä {data['link']} –ø—É—Å—Ç–æ–π, –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤ –¥–ª—è —Ä–µ–ø–æ—Å—Ç–∞ –≤ {channel_id}"
                        rootLogger.warning(log_msg)
                        write_daily_log(log_msg)
                    created_channels[selected_company].append({"id": channel_id, "name": name})
                    created_count += 1
                else:
                    log_msg = f"–£ {session.filename} –Ω–µ—Ç –ª–∏—á–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"
                    rootLogger.warning(log_msg)
                    write_daily_log(log_msg)
            except Exception as e:
                failed_sessions.append((session, str(e)))
                log_msg = f"–û—à–∏–±–∫–∞ —Ä–µ–ø–æ—Å—Ç–∞ –¥–ª—è {session.filename}: {str(e)}"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
    else:
        # –†–£–ß–ù–û–ô –í–í–û–î: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞
        def convert_entities_to_html(text, entities):
            if not text or not entities:
                return text or ""
            result = text
            for entity in sorted(entities, key=lambda e: e.offset, reverse=True):
                start = entity.offset
                end = entity.offset + entity.length
                if end > len(text):
                    end = len(text)
                if start >= end or start >= len(text) or start < 0:
                    continue
                entity_text = result[start:end]
                if entity.type == "bold":
                    replacement = f"<b>{entity_text}</b>"
                elif entity.type == "italic":
                    replacement = f"<i>{entity_text}</i>"
                elif entity.type == "spoiler":
                    replacement = f"<spoiler>{entity_text}</spoiler>"
                elif entity.type == "code":
                    replacement = f"<code>{entity_text}</code>"
                elif entity.type == "pre":
                    replacement = f"<pre>{entity_text}</pre>"
                elif entity.type == "underline":
                    replacement = f"<u>{entity_text}</u>"
                elif entity.type == "strikethrough":
                    replacement = f"<s>{entity_text}</s>"
                elif entity.type == "text_link":
                    url = entity.url
                    replacement = f'<a href="{url}">{entity_text}</a>'
                elif entity.type == "text_mention":
                    user_id = entity.user.id if hasattr(entity, 'user') and entity.user else entity_text
                    replacement = f'<a href="tg://user?id={user_id}">{entity_text}</a>'
                elif entity.type == "url":
                    replacement = f'<a href="{entity_text}">{entity_text}</a>'
                else:
                    rootLogger.warning(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø entity: {entity.type}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
                    continue
                result = result[:start] + replacement + result[end:]
            return result
        
        for session in ses:
            max_retries = 2
            retry_count = 0
            success = False
            last_error = None
            while retry_count < max_retries and not success:
                try:
                    if not session.app.is_connected():
                        log_msg = f"–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω, –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å"
                        rootLogger.warning(log_msg)
                        write_daily_log(log_msg)
                        await session.app.connect()
                    full_user = await session.app(functions.users.GetFullUserRequest(id=session.me.id))
                    channel_id = full_user.full_user.personal_channel_id
                    if channel_id:
                        log_msg = f"–°–µ—Å—Å–∏—è {session.filename}: —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–∞–Ω–∞–ª {channel_id}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        channel_entity = await session.app.get_entity(types.PeerChannel(channel_id))
                        if channel_entity.title != name:
                            try:
                                await session.app(functions.channels.EditTitleRequest(
                                    channel=channel_entity,
                                    title=name
                                ))
                                log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ '{name}' –¥–ª—è {session.filename}"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                            except ForbiddenError as e:
                                if "The chat or channel wasn't modified" in str(e):
                                    log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} —É–∂–µ '{name}', –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –¥–ª—è {session.filename}"
                                    rootLogger.info(log_msg)
                                    write_daily_log(log_msg)
                                else:
                                    raise
                        else:
                            log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} —É–∂–µ '{name}', –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –¥–ª—è {session.filename}"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                        if avatar:
                            if isinstance(avatar, str):  # file_id from bot
                                file_info = await bot.get_file(avatar)
                                photo_bytes = await bot.download_file(file_info.file_path)
                            else:  # bytes
                                photo_bytes = avatar
                            file = await session.app.upload_file(photo_bytes, file_name="avatar.jpg")
                            await session.app(functions.channels.EditPhotoRequest(
                                channel=channel_entity,
                                photo=file
                            ))
                            log_msg = f"–ê–≤–∞—Ç–∞—Ä–∫–∞ –∫–∞–Ω–∞–ª–∞ {channel_id} –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è {session.filename}"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                        async for msg in session.app.iter_messages(channel_id):
                            try:
                                await session.app.delete_messages(channel_id, [msg.id])
                            except Exception as e:
                                log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è {msg.id} –≤ –∫–∞–Ω–∞–ª–µ {channel_id}: {str(e)}"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                        log_msg = f"–í—Å–µ —Å—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã —É–¥–∞–ª–µ–Ω—ã –∏–∑ –∫–∞–Ω–∞–ª–∞ {channel_id} –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        for post in posts:
                            if post['type'] == 'text':
                                formatted_text = convert_entities_to_html(post['content'], post['entities'])
                                await session.app.send_message(channel_id, formatted_text, parse_mode='html')
                            elif post['type'] in ['photo', 'video']:
                                if 'media_bytes' in post:  # From copy
                                    media_bytes = post['media_bytes']
                                else:  # file_id from bot
                                    file_info = await bot.get_file(post['file_id'])
                                    media_bytes = await bot.download_file(file_info.file_path)
                                file_name = f"media.{post['type']}"
                                file = await session.app.upload_file(media_bytes, file_name=file_name)
                                formatted_caption = convert_entities_to_html(post['caption'], post['entities'])
                                await session.app.send_message(channel_id, formatted_caption, file=file, parse_mode='html')
                            elif post['type'] == 'album':
                                files = []
                                for photo in post['photos']:
                                    if 'media_bytes' in photo:
                                        media_bytes = photo['media_bytes']
                                    else:
                                        file_info = await bot.get_file(photo['file_id'])
                                        media_bytes = await bot.download_file(file_info.file_path)
                                    file = await session.app.upload_file(media_bytes, file_name="media.jpg")
                                    files.append(file)
                                formatted_caption = convert_entities_to_html(post['photos'][0]['caption'], post['photos'][0]['entities'])
                                await session.app.send_file(channel_id, files, caption=formatted_caption, parse_mode='html')
                        log_msg = f"–ö–∞–Ω–∞–ª {channel_id} –æ–±–Ω–æ–≤–ª—ë–Ω –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename}: –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ '{name}', –¥–æ–±–∞–≤–ª–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        created_channels[selected_company].append({"id": channel_id, "name": name})
                        created_count += 1
                    else:  # –ù–æ–≤—ã–π –∫–∞–Ω–∞–ª
                        log_msg = f"–°–µ—Å—Å–∏—è {session.filename}: —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        channel = await session.app(functions.channels.CreateChannelRequest(
                            title=name,
                            about="–°–æ–∑–¥–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏",
                            megagroup=False
                        ))
                        channel_entity = channel.chats[0]
                        channel_id = channel_entity.id
                        if avatar:
                            if isinstance(avatar, str):
                                file_info = await bot.get_file(avatar)
                                photo_bytes = await bot.download_file(file_info.file_path)
                            else:
                                photo_bytes = avatar
                            file = await session.app.upload_file(photo_bytes, file_name="avatar.jpg")
                            await session.app(functions.channels.EditPhotoRequest(
                                channel=channel_id,
                                photo=file
                            ))
                        for post in posts:
                            if post['type'] == 'text':
                                formatted_text = convert_entities_to_html(post['content'], post['entities'])
                                await session.app.send_message(channel_id, formatted_text, parse_mode='html')
                            elif post['type'] in ['photo', 'video']:
                                if 'media_bytes' in post:
                                    media_bytes = post['media_bytes']
                                else:
                                    file_info = await bot.get_file(post['file_id'])
                                    media_bytes = await bot.download_file(file_info.file_path)
                                file_name = f"media.{post['type']}"
                                file = await session.app.upload_file(media_bytes, file_name=file_name)
                                formatted_caption = convert_entities_to_html(post['caption'], post['entities'])
                                await session.app.send_message(channel_id, formatted_caption, file=file, parse_mode='html')
                            elif post['type'] == 'album':
                                files = []
                                for photo in post['photos']:
                                    if 'media_bytes' in photo:
                                        media_bytes = photo['media_bytes']
                                    else:
                                        file_info = await bot.get_file(photo['file_id'])
                                        media_bytes = await bot.download_file(file_info.file_path)
                                    file = await session.app.upload_file(media_bytes, file_name="media.jpg")
                                    files.append(file)
                                formatted_caption = convert_entities_to_html(post['photos'][0]['caption'], post['photos'][0]['entities'])
                                await session.app.send_file(channel_id, files, caption=formatted_caption, parse_mode='html')
                        base_username = "".join(TRANS_TABLE.get(c, c) for c in name.lower() if c.isalnum() or c in TRANS_TABLE)
                        username = f"{base_username[:20]}{session.me.id % 10000}"
                        i = 0
                        username_set = False
                        while i < 5:
                            try:
                                await session.app(functions.channels.UpdateUsernameRequest(
                                    channel=channel_entity,
                                    username=username
                                ))
                                username_set = True
                                log_msg = f"Username {username} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è –∫–∞–Ω–∞–ª–∞ {channel_id} –≤ —Å–µ—Å—Å–∏–∏ {session.filename}"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                                break
                            except FloodWaitError as e:
                                log_msg = f"–û–∂–∏–¥–∞–Ω–∏–µ {e.seconds} —Å–µ–∫—É–Ω–¥ –∏–∑-–∑–∞ FloodWait –¥–ª—è {session.filename}"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                await asyncio.sleep(e.seconds)
                            except UsernameOccupiedError:
                                i += 1
                                username = f"{base_username[:20]}{session.me.id % 10000}{i}"
                                log_msg = f"Username {username[:-1]} –∑–∞–Ω—è—Ç, –ø—Ä–æ–±—É–µ–º {username}"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                            except Exception as e:
                                log_msg = f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ username –¥–ª—è {session.filename}: {str(e)}"
                                rootLogger.error(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                break
                        if username_set:
                            try:
                                await session.app(functions.account.UpdatePersonalChannelRequest(channel=channel_entity))
                                log_msg = f"–ö–∞–Ω–∞–ª {username} —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω –∫–∞–∫ –ª–∏—á–Ω—ã–π –¥–ª—è {session.filename}"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                            except FloodWaitError as e:
                                log_msg = f"FloodWait –ø—Ä–∏ –ø—Ä–∏–≤—è–∑–∫–µ –∫–∞–Ω–∞–ª–∞ {username} –¥–ª—è {session.filename}: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                await asyncio.sleep(e.seconds)
                                continue
                            except Exception as e:
                                log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∏ –∫–∞–Ω–∞–ª–∞ {username} –¥–ª—è {session.filename}: {str(e)}"
                                rootLogger.error(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                        channel_link = f"https://t.me/{username}" if username_set else f"–ö–∞–Ω–∞–ª {channel_id} (–ø—Ä–∏–≤–∞—Ç–Ω—ã–π)"
                        log_msg = f"–ö–∞–Ω–∞–ª '{name}' —Å–æ–∑–¥–∞–Ω –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename} —Å ID {channel_id} –ø–æ —Å—Å—ã–ª–∫–µ {channel_link}, –¥–æ–±–∞–≤–ª–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        created_channels[selected_company].append({"id": channel_id, "name": name})
                        created_count += 1
                    success = True
                except Exception as e:
                    retry_count += 1
                    last_error = str(e)
                    rootLogger.warning(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –¥–ª—è {session.filename} (–ø–æ–ø—ã—Ç–∫–∞ {retry_count}/{max_retries}): {str(e)}")
                    if retry_count < max_retries:
                        await asyncio.sleep(5)
                    else:
                        failed_sessions.append((session, last_error))
                        log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –∫–∞–Ω–∞–ª –¥–ª—è {session.filename} –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫: {last_error}"
                        rootLogger.error(log_msg)
                        write_daily_log(log_msg)
                        await bot.send_message(chat_id, log_msg)
    
    # –û–±—â–∏–π –∫–æ–¥ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–¥–ª—è –æ–±–æ–∏—Ö —Å–ª—É—á–∞–µ–≤)
    with open(f"./companies/{selected_company}/created_channels.json", "w", encoding="utf-8") as file:
        json.dump(created_channels[selected_company], file, ensure_ascii=False)
    log_msg = f"–°–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {created_count} –∏–∑ {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤."
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    await bot.send_message(chat_id, log_msg)
    await message.edit_text(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: {created_count} –∏–∑ {len(ses)}")
    for failed_session, error in failed_sessions:
        error_msg = f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –¥–ª—è {failed_session.filename}: {error}"
        await bot.send_message(chat_id, error_msg)
        rootLogger.error(error_msg)
    await state.clear()
    await start(message)

async def worker_liking_stories(session: Session):
    company = session.company
    rootLogger.info(f"–ó–∞–ø—É—Å–∫ –ª–∞–π–∫–∏–Ω–≥–∞ —Å—Ç–æ—Ä–∏—Å –¥–ª—è {session.filename}, –∫–æ–º–ø–∞–Ω–∏—è {company}")
    try:
        while True:
            rootLogger.info(f"[DEBUG] –°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ —Å–µ—Å—Å–∏–∏ {session.filename}: {company_active.get(company, False)}")
            if not company_active.get(company, False):
                rootLogger.info(f"–õ–∞–π–∫–∏–Ω–≥ –¥–ª—è {session.filename} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∂–¥—ë–º –∞–∫—Ç–∏–≤–∞—Ü–∏–∏...")
                await asyncio.sleep(60)
                continue
            if not session.app.is_connected():
                log_msg = f"–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω, –ø—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è..."
                rootLogger.warning(log_msg)
                write_daily_log(log_msg)
                try:
                    await session.app.connect()
                    log_msg = f"–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á—ë–Ω"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
                except Exception as e:
                    log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}"
                    rootLogger.error(log_msg)
                    write_daily_log(log_msg)
                    await asyncio.sleep(60)
                    continue
            accounts_per_channel = company_configs[company].get('accounts_per_channel', 1)
            chat = None
            is_new_channel = False
            async with chat_lock:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT id, link FROM channels
                    WHERE status = 'pending'
                    LIMIT 1
                """)
                pending_result = cursor.fetchone()
                if pending_result:
                    channel_id_db, chat_link = pending_result
                    cursor.execute("""
                        UPDATE channels
                        SET status = 'processing', current_processed = 1
                        WHERE id = ?
                    """, (channel_id_db,))
                    conn.commit()
                    chat = chat_link
                    is_new_channel = True
                else:
                    cursor.execute("""
                        SELECT id, link FROM channels
                        WHERE status = 'processing' AND current_processed < ?
                        LIMIT 1
                    """, (accounts_per_channel,))
                    processing_result = cursor.fetchone()
                    if processing_result:
                        channel_id_db, chat_link = processing_result
                        cursor.execute("""
                            UPDATE channels
                            SET current_processed = current_processed + 1
                            WHERE id = ?
                        """, (channel_id_db,))
                        conn.commit()
                        chat = chat_link
                        is_new_channel = False
                    else:
                        conn.commit()
                        # –°–±—Ä–æ—Å processed –∫–∞–Ω–∞–ª–æ–≤ —Å—Ç–∞—Ä—à–µ 24 —á–∞—Å–æ–≤
                        cursor.execute("""
                            UPDATE channels
                            SET status = 'pending', current_processed = 0
                            WHERE status = 'processed'
                            AND last_processed < ?
                        """, ((datetime.now(pytz.UTC) - timedelta(hours=24)).strftime("%Y-%m-%d %H:%M:%S.%f"),))
                        conn.commit()
                        # UPDATE –±–µ–∑ RETURNING (SQLite –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç), –∑–∞—Ç–µ–º SELECT
                        cursor.execute("""
                            UPDATE channels
                            SET status = 'processing'
                            WHERE id = (
                                SELECT id FROM channels WHERE status = 'pending' LIMIT 1
                            )
                        """)
                        conn.commit()
                        cursor.execute("""
                            SELECT link FROM channels
                            WHERE status = 'processing'
                            ORDER BY id LIMIT 1
                        """)
                        result = cursor.fetchone()
                        if result:
                            chat = result[0]
                            is_new_channel = True
                        else:
                            await asyncio.sleep(300)
                            continue
                conn.commit()
            if not chat:
                await asyncio.sleep(300)
                continue
            try:
                chat_id = None
                chat_link = None
                is_invite_link = chat.startswith("t.me/+") or chat.startswith("https://t.me/+")
                if is_invite_link:
                    chat_id = await join_by_invite_link(session, chat) # –° retry –≤–Ω—É—Ç—Ä–∏
                    chat_link = chat
                    if not chat_id:
                        # –ï—Å–ª–∏ fail ‚Äî mark as processed (—á—Ç–æ–±—ã –Ω–µ retry –≤–µ—á–Ω–æ)
                        async with stats_lock:
                            if chat.startswith('@'):
                                company_stats[company]["channels_processed"] += 1
                            else:
                                company_stats[company]["chats_processed"] += 1
                        continue
                else:
                    try:
                        entity = await session.app.get_entity(chat)
                        if not entity:
                            raise ValueError("Entity is None")
                        chat_id = entity.id
                        chat_link = f"@{entity.username}" if entity.username else f"t.me/c/{chat_id}"
                        rootLogger.info(f"–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª–∞ {chat_link} –±–µ–∑ –ø–æ–¥–ø–∏—Å–∫–∏")
                    except (ChannelPrivateError, UserNotParticipantError) as e:
                        log_msg = f"–ö–∞–Ω–∞–ª {chat} –∑–∞–∫—Ä—ã—Ç—ã–π –∏–ª–∏ —Ç—Ä–µ–±—É–µ—Ç –ø–æ–¥–ø–∏—Å–∫–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º: {str(e)}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        cursor.execute("DELETE FROM channels WHERE link = ?", (chat,))
                        conn.commit()
                        async with stats_lock:
                            if chat.startswith('@'):
                                company_stats[company]["channels_processed"] += 1
                            else:
                                company_stats[company]["chats_processed"] += 1
                        await asyncio.sleep(20)
                        continue
                    except ValueError as e:
                        error_msg = str(e)
                        if "No user has" in error_msg or "An invalid Peer was used" in error_msg:
                            log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ—Å—Ç—É–ø–µ –∫ {chat} –¥–ª—è {session.filename}: {error_msg}. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ @spambot..."
                            rootLogger.warning(log_msg)
                            write_daily_log(log_msg)
                            status, reason = await check_session_status(session)
                            log_msg = f"–°—Ç–∞—Ç—É—Å —Å–µ—Å—Å–∏–∏ {session.filename} –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: {status} (–ø—Ä–∏—á–∏–Ω–∞: {reason or '–Ω–µ—Ç'})"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                            if status == "–∫—Ä–∞—Å–Ω—ã–π":
                                session_path = f"./companies/{session.company}/sessions/{session.filename}"
                                await move_to_spamblocked(session_path)
                                sessions.remove(session)
                                log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ ./spamblocked_sessions (—Å—Ç–∞—Ç—É—Å: {status}, –ø—Ä–∏—á–∏–Ω–∞: {reason})"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                return # –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–¥–∞—á—É
                            await asyncio.sleep(20)
                            continue
                        else:
                            log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ {chat}: {str(e)}"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                            if "chat not found" in str(e).lower():
                                cursor.execute("DELETE FROM channels WHERE link = ?", (chat,))
                                conn.commit()
                            if chat.startswith('@'):
                                async with stats_lock:
                                    company_stats[company]["channels_processed"] += 1
                            else:
                                async with stats_lock:
                                    company_stats[company]["chats_processed"] += 1
                            await asyncio.sleep(20)
                            continue
                rootLogger.info(f"–ü–µ—Ä–µ—à—ë–ª –≤ —á–∞—Ç {chat_id} –ø–æ —Å—Å—ã–ª–∫–µ {chat_link}")
                users_to_process = []
                entity = await session.app.get_entity(chat_id)
                entity_type = await determine_entity_type(session, entity)
                if entity_type == "channel":
                    users_to_process = await process_channel(session, chat_id)
                    async with stats_lock:
                        company_stats[company]["channels_processed"] += 1
                elif entity_type == "chat":
                    chat_type = await determine_chat_type(session, chat_id)
                    users_to_process = await parse_open_chat(session, chat_id) if chat_type == "open" else await parse_closed_chat(session, chat_id)
                    async with stats_lock:
                        company_stats[company]["chats_processed"] += 1
                else:
                    rootLogger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å—É—â–Ω–æ—Å—Ç–∏ –¥–ª—è {chat}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
                    await asyncio.sleep(20)
                    continue
                processed_users = 0
                for user_id in users_to_process:
                    if not company_active.get(company, False):
                        break
                    try:
                        await process_user_stories(session, user_id)
                        processed_users += 1
                        await asyncio.sleep(random.uniform(1, 2))
                    except ValueError as e:
                        error_msg = str(e)
                        if "No user has" in error_msg or "An invalid Peer was used" in error_msg:
                            log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç–æ—Ä–∏—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –¥–ª—è {session.filename}: {error_msg}. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å —á–µ—Ä–µ–∑ @spambot..."
                            rootLogger.warning(log_msg)
                            write_daily_log(log_msg)
                            status, reason = await check_session_status(session)
                            log_msg = f"–°—Ç–∞—Ç—É—Å —Å–µ—Å—Å–∏–∏ {session.filename} –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: {status} (–ø—Ä–∏—á–∏–Ω–∞: {reason or '–Ω–µ—Ç'})"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                            if status == "–∫—Ä–∞—Å–Ω—ã–π":
                                session_path = f"./companies/{session.company}/sessions/{session.filename}"
                                await move_to_spamblocked(session_path)
                                sessions.remove(session)
                                log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ ./spamblocked_sessions (—Å—Ç–∞—Ç—É—Å: {status}, –ø—Ä–∏—á–∏–Ω–∞: {reason})"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                return # –ó–∞–≤–µ—Ä—à–∞–µ–º –∑–∞–¥–∞—á—É
                            await asyncio.sleep(10)
                            break
                        else:
                            log_msg = f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å—Ç–æ—Ä–∏—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –¥–ª—è {session.filename}: {error_msg}"
                            rootLogger.error(log_msg)
                            write_daily_log(log_msg)
                            await asyncio.sleep(5)
                log_msg = f"–ê–∫–∫–∞—É–Ω—Ç {session.filename} –∑–∞–≤–µ—Ä—à–∏–ª –æ–±—Ä–∞–±–æ—Ç–∫—É —á–∞—Ç–∞ {chat_link}: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {processed_users} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π."
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
                # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫–∞–Ω–∞–ª–∞ (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π SELECT)
                async with chat_lock:
                    cursor = conn.cursor()
                    cursor.execute("SELECT current_processed FROM channels WHERE link = ?", (chat,))
                    row = cursor.fetchone()
                    curr_processed = row[0] if row else 0
                    if curr_processed >= accounts_per_channel:
                        cursor.execute("""
                            UPDATE channels
                            SET status = 'processed', last_processed = ?
                            WHERE link = ?
                        """, (datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S.%f"), chat))
                    conn.commit()
                await asyncio.sleep(8)
            except Exception as e:
                rootLogger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {chat} –¥–ª—è {session.filename}: {str(e)}")
                if "chat not found" in str(e).lower():
                    cursor.execute("DELETE FROM channels WHERE link = ?", (chat,))
                    conn.commit()
                await asyncio.sleep(60)
    except asyncio.CancelledError:
        rootLogger.info(f"–õ–∞–π–∫–∏–Ω–≥ –¥–ª—è {session.filename} –æ—Ç–º–µ–Ω—ë–Ω")
        if session.app and session.app.is_connected():
            await session.app.disconnect()
            if hasattr(session.app, '_sender') and session.app._sender:
                await session.app._sender.disconnect()
        raise
    except Exception as e:
        rootLogger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ worker_liking_stories –¥–ª—è {session.filename}: {str(e)}")
        if session.app and session.app.is_connected():
            await session.app.disconnect()
            if hasattr(session.app, '_sender') and session.app._sender:
                await session.app._sender.disconnect()
async def join_by_invite_link(session, invite_link) -> Optional[int]: # –î–æ–±–∞–≤–ª–µ–Ω return type
    max_retries = 2
    for attempt in range(max_retries):
        try:
            if invite_link.startswith("t.me/+"):
                invite_hash = invite_link.split("+")[1].strip()
            elif invite_link.startswith("https://t.me/+"):
                invite_hash = invite_link.split("+")[1].strip()
            else:
                raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–∏")
            result = await session.app(functions.messages.ImportChatInviteRequest(invite_hash))
            chat = result.chats[0]
            rootLogger.info(f"–ê–∫–∫–∞—É–Ω—Ç {session.filename} –≤—Å—Ç—É–ø–∏–ª –≤ —á–∞—Ç {chat.id} –ø–æ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–µ {invite_link}")
            write_daily_log(f"–ê–∫–∫–∞—É–Ω—Ç {session.filename} –≤—Å—Ç—É–ø–∏–ª –≤ —á–∞—Ç {chat.id} –ø–æ {invite_link}")
            return chat.id # Explicit return
        except FloodWaitError as e:
            rootLogger.warning(f"FloodWait –Ω–∞ join {invite_link}: {e.seconds}s, retry {attempt+1}/{max_retries}")
            await asyncio.sleep(e.seconds)
        except Exception as e:
            error_msg = str(e)
            if "INVITE_HASH_INVALID" in error_msg or "USER_ALREADY_PARTICIPANT" in error_msg:
                rootLogger.warning(f"–ù–µ–≤–µ—Ä–Ω–∞—è/–Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å—Å—ã–ª–∫–∞ {invite_link}, —É–¥–∞–ª—è–µ–º –∏–∑ –ë–î")
                write_daily_log(f"–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞ {invite_link}, —É–¥–∞–ª–µ–Ω–∞")
                cursor = conn.cursor()
                cursor.execute("DELETE FROM channels WHERE link = ?", (invite_link,))
                conn.commit()
                return None
            if "No user has" in error_msg or "You're banned" in error_msg or "An invalid Peer" in error_msg:
                log_msg = f"–û—à–∏–±–∫–∞ join {invite_link} –¥–ª—è {session.filename}: {error_msg}. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–∞–º–±–æ—Ç..."
                rootLogger.warning(log_msg)
                write_daily_log(log_msg)
                status, reason = await check_session_status(session)
                log_msg = f"–°—Ç–∞—Ç—É—Å {session.filename}: {status} ({reason or '–Ω–µ—Ç'})"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
                if status == "–∫—Ä–∞—Å–Ω—ã–π":
                    session_path = f"./companies/{session.company}/sessions/{session.filename}"
                    await move_to_spamblocked(session_path)
                    sessions.remove(session)
                    await bot.send_message(chat_id, log_msg)
                return None
            if attempt < max_retries - 1:
                rootLogger.warning(f"Retry join {invite_link} ({attempt+1}/{max_retries}): {error_msg}")
                await asyncio.sleep(5)
            else:
                rootLogger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å join {invite_link} –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫: {error_msg}")
                return None
    return None
async def periodic_save_stats():
    while True:
        try:
            # –°–û–•–†–ê–ù–Ø–ï–ú –ö–û–ù–§–ò–ì–ò –ö–û–ú–ü–ê–ù–ò–ô
            for company in company_configs.keys():
                config_file = f"./companies/{company}/config.json"
                try:
                    with open(config_file, "w", encoding='utf-8') as f:
                        json.dump(company_configs[company], f, ensure_ascii=False)
                    rootLogger.info(f"–°–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –¥–ª—è {company} –≤ {config_file}")
                except Exception as e:
                    rootLogger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è {company}: {str(e)}")
            # –°–û–•–†–ê–ù–Ø–ï–ú –°–¢–ê–¢–ò–°–¢–ò–ö–£
            for company in company_stats.keys():
                async with stats_lock:
                    save_stats(company)
            await asyncio.sleep(300)
        except Exception as e:
            rootLogger.error(f"–û—à–∏–±–∫–∞ –≤ periodic_save_stats: {str(e)}")
            await asyncio.sleep(300)
async def remove_inactive_sessions():
    global sessions
    now = datetime.now(pytz.UTC)
    inactive_sessions = []
   
    for session in sessions:
        try:
            if not session.app.is_connected():
                await session.app.connect()
            me = await session.app.get_me()
            if not me:
                inactive_sessions.append(session)
                continue
            if me.status and hasattr(me.status, 'was_online'):
                last_online = me.status.was_online
                if last_online and (now - last_online).days > 7:
                    inactive_sessions.append(session)
        except Exception as e:
            rootLogger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}")
            inactive_sessions.append(session)
   
    for session in inactive_sessions:
        try:
            session_path = f"./companies/{session.company}/sessions/{session.filename}"
            await move_to_banned(session_path)
            sessions.remove(session)
            rootLogger.info(f"–°–µ—Å—Å–∏—è {session.filename} —É–¥–∞–ª–µ–Ω–∞ –∫–∞–∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞—è")
            await bot.send_message(chat_id, f"–°–µ—Å—Å–∏—è {session.filename} —É–¥–∞–ª–µ–Ω–∞ –∫–∞–∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞—è")
        except Exception as e:
            rootLogger.error(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–π —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}")
async def add_to_contacts(session, username):
    try:
        user = await session.app.get_entity(username)
        await session.app(functions.contacts.AddContactRequest(
            id=user.id,
            first_name=user.first_name or "",
            last_name=user.last_name or "",
            phone=user.phone or ""
        ))
        log_msg = f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {username} –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã —Å–µ—Å—Å–∏–∏ {session.filename}"
        rootLogger.info(log_msg)
        write_daily_log(log_msg)
    except Exception as e:
        log_msg = f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è {username} –≤ –∫–æ–Ω—Ç–∞–∫—Ç—ã –¥–ª—è {session.filename}: {str(e)}"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
@dp.message(SendPMState.username, (F.from_user.id == owner_id))
async def process_pm_username(message: atypes.Message, state: FSMContext):
    username = message.text.strip()
    if not username:
        await message.reply("–Æ–∑–µ—Ä–Ω–µ–π–º –∏–ª–∏ ID –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.")
        return
    await state.clear()
   
    ses = [s for s in sessions if s.me and s.company == selected_company]
    if not ses:
        await message.reply(f"–í –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company} –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π.")
        return
   
    await message.reply(f"–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è '{username}' –æ—Ç {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –Ω–∞—á–∞–ª–∞—Å—å...")
   
    success_count = 0
    for session in ses:
        try:
            await session.app.send_message(username, "1")
            log_msg = f"–ê–∫–∫–∞—É–Ω—Ç {session.filename} –æ—Ç–ø—Ä–∞–≤–∏–ª —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {username}"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
            success_count += 1
            await add_to_contacts(session, username)
        except FloodWaitError as e:
            log_msg = f"FloodWait –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç {session.filename} –∫ {username}: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥"
            rootLogger.warning(log_msg)
            write_daily_log(log_msg)
            await bot.send_message(chat_id, log_msg)
            await asyncio.sleep(e.seconds)
            continue
        except Exception as e:
            log_msg = f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç {session.filename}: {str(e)}"
            rootLogger.error(log_msg)
            write_daily_log(log_msg)
            await bot.send_message(chat_id, log_msg)
       
        await asyncio.sleep(1)
    log_msg = f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –¥–ª—è {success_count} –∏–∑ {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤."
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    await bot.send_message(chat_id, log_msg)
    await message.reply(f"–û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –¥–ª—è {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤.")
    await start(message)
async def start(message: atypes.Message):
    global selected_company
    log_msg = f"–ó–∞–ø—É—Å–∫ –∫–æ–º–∞–Ω–¥—ã /start. –¢–µ–∫—É—â–∞—è –∫–æ–º–ø–∞–Ω–∏—è: {selected_company}"
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions)) if selected_company else []
    log_msg = f"–ù–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}: {len(ses)}"
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
   
    if selected_company is None:
        stats = get_all_stats()
        kb_companies = atypes.InlineKeyboardMarkup(inline_keyboard=list(
            map(lambda x: [atypes.InlineKeyboardButton(text=x, callback_data="sel_company_" + x)],
                listdir("./companies"))
            ) + [[atypes.InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –∫–æ–º–ø–∞–Ω–∏—é", callback_data="create_company")],
                 [atypes.InlineKeyboardButton(text="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="account_stats")]])
        await message.reply(f"–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –≤—Å–µ–º –∫–æ–º–ø–∞–Ω–∏—è–º:\n{stats}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é:", reply_markup=kb_companies)
    else:
        await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:", reply_markup=kb_menu)
async def update_stats_message(chat_id, message_id, company):
    while True:
        try:
            async with stats_lock:
                stats_text = get_stats_text(company)
            await bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=stats_text,
                reply_markup=kb_menu
            )
            await asyncio.sleep(120)
        except FloodWaitError as e:
            rootLogger.warning(f"FloodWait –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥")
            await bot.send_message(chat_id, f"FloodWait –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥")
            await asyncio.sleep(e.seconds)
        except Exception as e:
            if "message is not modified" not in str(e).lower():
                rootLogger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {str(e)}")
            await asyncio.sleep(60)
@dp.message(CollectViewsStatsState.channel_name, (F.from_user.id == owner_id))
async def process_channel_name(message: atypes.Message, state: FSMContext):
    await state.clear()
    await message.reply("–°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–º –∫–∞–Ω–∞–ª–∞–º –Ω–∞—á–∞–ª—Å—è...")
    await collect_created_views_stats(message)
    await start(message)
async def determine_entity_type(session, entity):
    try:
        if isinstance(entity, types.Chat):
            return "chat"
        elif isinstance(entity, types.Channel):
            if entity.broadcast:
                return "channel"
            elif entity.megagroup:
                return "chat"
            else:
                participant = await session.app(functions.channels.GetParticipantRequest(
                    channel=entity,
                    participant=await session.app.get_me()
                ))
                if participant.participant._constructor_id == types.ChannelParticipant._constructor_id:
                    return "chat"
                return "channel"
        return "unknown"
    except Exception as e:
        rootLogger.error(f"–û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ —Å—É—â–Ω–æ—Å—Ç–∏ {entity.id}: {str(e)}")
        return "unknown"
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "send_pm"))
async def start_send_pm(callback: atypes.CallbackQuery, state: FSMContext):
    if not selected_company:
        await callback.message.edit_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é.")
        return
    await state.set_state(SendPMState.username)
    await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —é–∑–µ—Ä–Ω–µ–π–º –∏–ª–∏ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:")
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "check_account_status"))
async def check_account_status(callback: atypes.CallbackQuery):
    if not selected_company:
        await callback.message.edit_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é.")
        return
    log_msg = f"–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}"
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    company_sessions = [s for s in sessions if s.company == selected_company and s.app]
    if not company_sessions:
        await callback.message.edit_text(f"–í –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company} –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π.")
        return
    await callback.message.edit_text(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}...")
    checked_count = 0
    green_count = 0
    yellow_count = 0
    red_count = 0
    for session in company_sessions:
        status, reason = await check_session_status(session)
        checked_count += 1
        log_msg = f"–°—Ç–∞—Ç—É—Å —Å–µ—Å—Å–∏–∏ {session.filename} –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: {status} (–ø—Ä–∏—á–∏–Ω–∞: {reason or '–Ω–µ—Ç'})"
        rootLogger.info(log_msg)
        write_daily_log(log_msg)
        if status == "–∑–µ–ª—ë–Ω—ã–π":
            green_count += 1
        elif status == "–∂—ë–ª—Ç—ã–π":
            yellow_count += 1
        elif status == "–∫—Ä–∞—Å–Ω—ã–π":
            red_count += 1
            session_path = f"./companies/{session.company}/sessions/{session.filename}"
            await move_to_spamblocked(session_path)
            sessions.remove(session)
            log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ ./spamblocked_sessions (—Å—Ç–∞—Ç—É—Å: {status}, –ø—Ä–∏—á–∏–Ω–∞: {reason})"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
            await bot.send_message(chat_id, log_msg)
    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    stats_msg = (f"–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}:\n"
                 f"- –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ –∞–∫–∫–∞—É–Ω—Ç–æ–≤: {checked_count}\n"
                 f"- –ó–µ–ª—ë–Ω—ã—Ö: {green_count}\n"
                 f"- –ñ—ë–ª—Ç—ã—Ö: {yellow_count}\n"
                 f"- –ö—Ä–∞—Å–Ω—ã—Ö: {red_count}")
    rootLogger.info(stats_msg)
    write_daily_log(stats_msg)
    await bot.send_message(chat_id, stats_msg)
    await callback.message.edit_text(stats_msg)
kb_company_menu = atypes.InlineKeyboardMarkup(inline_keyboard=[
    [atypes.InlineKeyboardButton(text="–í—ã–±—Ä–∞—Ç—å –∫–æ–º–ø–∞–Ω–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã", callback_data="toggle_companies")],
    [atypes.InlineKeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã", callback_data="setup_params")],
    [atypes.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_menu")]
])
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "toggle_story_liking"))
async def toggle_story_liking(callback: atypes.CallbackQuery, state: FSMContext):
    await callback.message.edit_text("–ú–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–º–ø–∞–Ω–∏—è–º–∏:", reply_markup=kb_company_menu)
    await callback.answer()
# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∫–æ–º–ø–∞–Ω–∏–∏
@dp.callback_query((F.from_user.id == owner_id) & (F.data.startswith("company_toggle:")))
async def process_company_toggle(callback: atypes.CallbackQuery, state: FSMContext):
    global company_active, liking_tasks, sessions
    try:
        callback_data = CompanyToggleCallback.unpack(callback.data)
        company_name = callback_data.company_name
        action = callback_data.action
        if action == "toggle":
            is_liking = company_active.get(company_name, False)
            company_active[company_name] = not is_liking
            ses = [s for s in sessions if s.company == company_name and s.me]
            status = "‚úÖ" if company_active[company_name] else "‚ùå"
            button_text = f"{status} {company_name}"
            await callback.message.edit_reply_markup(
                reply_markup=await build_toggle_keyboard(state)
            )
            await callback.answer(f"–õ–∞–π–∫–∏–Ω–≥ –¥–ª—è {company_name} {'–≤–∫–ª—é—á—ë–Ω' if company_active[company_name] else '–≤—ã–∫–ª—é—á–µ–Ω'}")
    except ValueError as e:
        await callback.answer("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return
async def build_toggle_keyboard(state: FSMContext):
    data = await state.get_data()
    selected_companies = data.get("selected_companies", [])
    keyboard = []
    for company in company_configs.keys():
        ses = [s for s in sessions if s.company == company and s.me]
        is_liking = company_active.get(company, False)
        status = "‚úÖ" if is_liking else "‚ùå"
        button_text = f"{status} {company}"
        button = InlineKeyboardButton(
            text=button_text,
            callback_data=CompanyToggleCallback(action="toggle", company_name=company).pack()
        )
        keyboard.append([button])
    done_button = InlineKeyboardButton(text="–ì–æ—Ç–æ–≤–æ", callback_data="done_toggling")
    keyboard.append([done_button])
    return InlineKeyboardMarkup(inline_keyboard=keyboard)
@dp.callback_query(ChangeState.select, (F.from_user.id == owner_id) & (F.data.in_({"select_all", "select_selective"})))
async def sel_accs(callback: atypes.CallbackQuery, state: FSMContext):
    global sessions
    report_sent = False
    try:
        ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
        if not ses:
            await bot.edit_message_text(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                text="–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è —ç—Ç–æ–π –∫–æ–º–ø–∞–Ω–∏–∏."
            )
            await state.clear()
            await start(callback.message)
            return
        data = await state.get_data()
        change = data.get("change", "")
        if callback.data == "select_all":
            await state.update_data(select=[int(session.me.id) for session in ses])
            log_msg = f"–í—ã–±—Ä–∞–Ω—ã –≤—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}: {len(ses)}"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
            max_attempts = 1
            attempt = 0
            while attempt < max_attempts:
                try:
                    await apply_data(callback, state, change=change)
                    break
                except Exception as e:
                    attempt += 1
                    if attempt < max_attempts:
                        log_msg = f"–ü–æ–ø—ã—Ç–∫–∞ {attempt}/{max_attempts}: –û—à–∏–±–∫–∞, –ø–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã: {str(e)}"
                        rootLogger.warning(log_msg)
                        write_daily_log(log_msg)
                        await asyncio.sleep(3)
                    else:
                        log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ {max_attempts} –ø–æ–ø—ã—Ç–æ–∫: {str(e)}"
                        rootLogger.error(log_msg)
                        write_daily_log(log_msg)
                        await bot.edit_message_text(
                            chat_id=callback.message.chat.id,
                            message_id=callback.message.message_id,
                            text="–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π."
                        )
            report_text = f"–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ {len(ses)} {'—Å–µ—Å—Å–∏–∏' if len(ses) == 1 else '—Å–µ—Å—Å–∏—è–º'}"
            attempt = 0
            while attempt < max_attempts:
                try:
                    await bot.edit_message_text(
                        chat_id=callback.message.chat.id,
                        message_id=callback.message.message_id,
                        text=report_text
                    )
                    report_sent = True
                    break
                except Exception as e:
                    attempt += 1
                    if attempt < max_attempts:
                        await asyncio.sleep(3)
                    else:
                        await bot.send_message(chat_id, f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á—ë—Ç: {str(e)}")
        elif callback.data == "select_selective":
            await state.update_data(select=[])
            builder = InlineKeyboardBuilder()
            for session in ses:
                me = session.me
                builder.row(atypes.InlineKeyboardButton(
                    text=f"‚ùå {me.first_name}{' ' + me.last_name if me.last_name else ''} ({'@' + me.username if me.username else '+' + me.phone_number if me.phone_number else str(me.id)} {me.id})",
                    callback_data=f"select_{me.id}"))
            builder.row(atypes.InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="select_done"))
            await bot.edit_message_text(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                text="–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã:",
                reply_markup=builder.as_markup()
            )
        await callback.answer()
    except Exception as e:
        log_msg = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ sel_accs: {str(e)}"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        if not report_sent:
            await bot.edit_message_text(
                chat_id=callback.message.chat.id,
                message_id=callback.message.message_id,
                text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞."
            )
async def move_to_spamblocked(session_path: str):
    filename = os.path.basename(session_path)
    spamblocked_path = os.path.join("./spamblocked_sessions", filename)
    max_attempts = 5
    attempt = 0
    session = next((s for s in sessions if f"./companies/{s.company}/sessions/{s.filename}" == session_path), None)
    if session and session.app and session.app.is_connected():
        await session.app.disconnect()
        if hasattr(session.app, '_sender') and session.app._sender:
            session.app._sender.disconnect()
        await asyncio.sleep(1) # –î–∞—ë–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏–µ —Ñ–∞–π–ª–∞
    while attempt < max_attempts:
        try:
            if not os.path.exists(session_path):
                log_msg = f"–û—à–∏–±–∫–∞: –§–∞–π–ª —Å–µ—Å—Å–∏–∏ {filename} –Ω–µ –Ω–∞–π–¥–µ–Ω"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
                return
            if not os.path.exists("./spamblocked_sessions"):
                os.makedirs("./spamblocked_sessions")
            shutil.move(session_path, spamblocked_path)
            log_msg = f"–°–µ—Å—Å–∏—è {filename} –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ ./spamblocked_sessions"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
            json_filename = filename.replace('.session', '.json')
            source_json_path = session_path.replace(filename, json_filename)
            target_json_path = os.path.join("./spamblocked_sessions", json_filename)
            if os.path.exists(source_json_path):
                shutil.move(source_json_path, target_json_path)
                log_msg = f"JSON-—Ñ–∞–π–ª {json_filename} –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ ./spamblocked_sessions"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
            return
        except Exception as e:
            attempt += 1
            if attempt < max_attempts:
                await asyncio.sleep(2)
            else:
                log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Å–µ—Å—Å–∏—é {filename}: {str(e)}"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "done_toggling"))
async def process_done_toggling(callback: atypes.CallbackQuery, state: FSMContext):
    global company_active, liking_tasks, sessions
    await state.clear() # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    # –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –º–∞—Å—Å–ª—É–∫–∏–Ω–≥ –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–∞–Ω–∏–π, –≥–¥–µ company_active == True
    for company in company_configs.keys():
        if company_active.get(company, False):
            ses = [s for s in sessions if s.company == company and s.me]
            for session in ses:
                if not any(task[1] == session for task in liking_tasks): # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞ –ª–∏ –∑–∞–¥–∞—á–∞
                    task = asyncio.create_task(worker_liking_stories(session))
                    liking_tasks.append((task, session))
                    rootLogger.info(f"–ó–∞–ø—É—â–µ–Ω–∞ –∑–∞–¥–∞—á–∞ –º–∞—Å—Å–ª—É–∫–∏–Ω–≥–∞ –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} (–∫–æ–º–ø–∞–Ω–∏—è {company})")
    await callback.message.edit_text("–ú–∞—Å—Å–ª—É–∫–∏–Ω–≥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –∑–∞–ø—É—â–µ–Ω –¥–ª—è –≤—Å–µ—Ö –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–æ–º–ø–∞–Ω–∏–π.")
    await callback.answer()
    await start(callback.message) # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –º–µ–Ω—é
async def check_session_status(session: Session) -> tuple[str, str | None]:
    if not session.app or not session.me:
        log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        return "–∫—Ä–∞—Å–Ω—ã–π", "banned"
    try:
        status, reason = await handle_spam_block(session.app)
        if status:
            log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –∏–º–µ–µ—Ç —Å—Ç–∞—Ç—É—Å: {status} (–ø—Ä–∏—á–∏–Ω–∞: {reason or '–Ω–µ—Ç'})"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
        return status, reason
    except Exception as e:
        log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        return "–∫—Ä–∞—Å–Ω—ã–π", "–æ—à–∏–±–∫–∞"
async def activate_session(session):
    try:
        await session.app.start(phone=f"+{session.filename[:-8]}")
        me = await session.app.get_me()
        if me:
            session.id == me.id
            session.me = me
            if not session.app.is_connected():
                await session.app.connect()
            log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ —Å ID {me.id}"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
            return True
        else:
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
    except Exception as e:
        log_msg = f"–û—à–∏–±–∫–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        return False
async def set_bot_commands(bot: Bot):
    commands = [
        BotCommand(command="start", description="–ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º"),
        BotCommand(command="stats_all", description="–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –≤—Å–µ–º –∫–æ–º–ø–∞–Ω–∏—è–º"),
        BotCommand(command="cancel", description="–û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é"),
        BotCommand(command="blacklist", description="–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫"),
        BotCommand(command="view_blacklist", description="–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫")
    ]
    await bot.set_my_commands(commands)
    rootLogger.info("–ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã —á–µ—Ä–µ–∑ setMyCommands")
async def main():
    for company_path in listdir("./companies"):
        users_paused[company_path] = True
        company_active[company_path] = False
        rootLogger.info(f"–ö–æ–º–ø–∞–Ω–∏—è {company_path} –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –¥–ª—è –ª–∞–π–∫–∏–Ω–≥–∞ —Å—Ç–æ—Ä–∏—Å")
    company_files = listdir("./companies")
    for company_path in company_files:
        session_files = [f for f in listdir(f"./companies/{company_path}/sessions") if f.endswith('.session')]
        for session_file_path in session_files:
            full_path = f"./companies/{company_path}/sessions/{session_file_path}"
            client = make_client(full_path)
            session = Session(client, session_file_path, company_path)
            sessions.append(session)
            log_msg = f"–°–µ—Å—Å–∏—è {session_file_path} –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ sessions"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
    await set_bot_commands(bot)
    tasks = [activate_session(session) for session in sessions]
    try:
        results = await asyncio.gather(*tasks, return_exceptions=True)
        inactive_sessions = []
        for session, result in zip(sessions[:], results):
            if result is False or isinstance(result, Exception):
                log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞: {str(result)}"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                if session.app:
                    if session.app.is_connected():
                        rootLogger.info(f"–ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ–º")
                        await session.app.disconnect()
                        if hasattr(session.app, '_sender') and session.app._sender:
                            await session.app._sender.disconnect()
                        await asyncio.sleep(2)
                    else:
                        rootLogger.info(f"–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} —É–∂–µ –æ—Ç–∫–ª—é—á—ë–Ω")
                session_path = f"./companies/{session.company}/sessions/{session.filename}"
                if "The used phone number has been banned" in str(result):
                    await move_to_banned(session_path)
                    sessions.remove(session)
                    log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ Telegram –∏ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ sessions"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
                else:
                    # –î–æ–±–∞–≤—å –¥–ª—è unauthorized
                    bad_auth_folder = f"./companies/{session.company}/BAD_AUTH"
                    os.makedirs(bad_auth_folder, exist_ok=True)
                    shutil.move(session_path, bad_auth_folder)
                    log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –Ω–µ–∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–∞, –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ BAD_AUTH"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ—Å—Å–∏–π —á–µ—Ä–µ–∑ @spambot –ø–æ—Å–ª–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ (batch –ø–æ 10)
        problematic_sessions = []
        batch_size = 10
        batches = [sessions[i:i + batch_size] for i in range(0, len(sessions), batch_size)]
        for batch_idx, batch in enumerate(batches, 1):
            batch_results = await asyncio.gather(*[handle_spam_block(session.app) for session in batch if session.app.is_connected()], return_exceptions=True)
            for session, result in zip(batch, batch_results):
                if isinstance(result, Exception):
                    status, reason = "–∫—Ä–∞—Å–Ω—ã–π", str(result)
                else:
                    status, reason = result or ("–∑–µ–ª—ë–Ω—ã–π", None)
                log_msg = f"–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Å—Å–∏–∏ {session.filename} —á–µ—Ä–µ–∑ @{FROZE_CHECK_BOT_USERNAME}: {status}, –ø—Ä–∏—á–∏–Ω–∞: {reason or '–Ω–µ—Ç'}"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
                if status in ["–∂—ë–ª—Ç—ã–π", "–∫—Ä–∞—Å–Ω—ã–π"]:
                    problematic_sessions.append(session)
                    session_path = f"./companies/{session.company}/sessions/{session.filename}"
                    try:
                        await move_to_spamblocked(session_path)
                        log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ ./spamblocked_sessions (—Å—Ç–∞—Ç—É—Å: {status})"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        await bot.send_message(chat_id, log_msg)
                    except Exception as e:
                        log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–∏ —Å–µ—Å—Å–∏–∏ {session.filename}: {str(e)}"
                        rootLogger.error(log_msg)
                        write_daily_log(log_msg)
                        await bot.send_message(chat_id, log_msg)
                else:
                    if not session.me:
                        me = await session.app.get_me()
                        session.id = me.id
                        session.me = me
                    log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –∞–∫—Ç–∏–≤–Ω–∞ (ID: {session.id})"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
            rootLogger.info(f"Batch —Å–ø–∞–º–±–æ—Ç {batch_idx}/{len(batches)} –∑–∞–≤–µ—Ä—à—ë–Ω: {len(batch)} —Å–µ—Å—Å–∏–π")
            await asyncio.sleep(1) # –ü–∞—É–∑–∞ –º–µ–∂–¥—É batches
        # –£–¥–∞–ª—è–µ–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –∏–∑ —Å–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–Ω—ã—Ö
        for session in problematic_sessions:
            if session in sessions:
                sessions.remove(session)
                log_msg = f"–°–µ—Å—Å–∏—è {session.filename} —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
        if not os.path.exists("./banned_sessions"):
            os.makedirs("./banned_sessions")
        for session in inactive_sessions:
            if session.app:
                if session.app.is_connected():
                    rootLogger.info(f"–ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º")
                    await session.app.disconnect()
                    if hasattr(session.app, '_sender') and session.app._sender:
                        await session.app._sender.disconnect()
                    await asyncio.sleep(2)
                else:
                    rootLogger.info(f"–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} —É–∂–µ –æ—Ç–∫–ª—é—á—ë–Ω")
            session_path = f"./companies/{session.company}/sessions/{session.filename}"
            await move_to_banned(session_path)
            sessions.remove(session)
            log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ –∏ —É–¥–∞–ª–µ–Ω–∞"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
        active_sessions = [s for s in sessions if s.me is not None]
        log_msg = f"–ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –ø–æ—Å–ª–µ –ø—Ä–æ–≤–µ—Ä–∫–∏: {len(active_sessions)}"
        rootLogger.info(log_msg)
        write_daily_log(log_msg)
        global liking_tasks
        liking_tasks.clear()
        for session in active_sessions:
            if company_active.get(session.company, False):
                task = asyncio.create_task(worker_liking_stories(session))
                liking_tasks.append((task, session))
                rootLogger.info(f"–ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –∑–∞–ø—É—â–µ–Ω–∞ –∑–∞–¥–∞—á–∞ –ª–∞–π–∫–∏–Ω–≥–∞ –¥–ª—è {session.filename}")
        asyncio.create_task(periodic_save_stats())
        scheduler.start()
        scheduler.add_job(remove_inactive_sessions, "interval", days=1, timezone=pytz.UTC)
        asyncio.create_task(dp.start_polling(bot, handle_as_tasks=False, handle_signals=False))
        await asyncio.Future()
    except Exception as e:
        log_msg = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ main: {str(e)}"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        await bot.send_message(chat_id, log_msg)
async def move_to_banned(session_path: str):
    filename = os.path.basename(session_path)
    banned_path = os.path.join("./banned_sessions", filename)
    max_attempts = 5
    attempt = 0
    session = next((s for s in sessions if f"./companies/{s.company}/sessions/{s.filename}" == session_path), None)
    if session and session.app and session.app.is_connected():
        await session.app.disconnect()
    while attempt < max_attempts:
        try:
            if not os.path.exists(session_path):
                log_msg = f"–û—à–∏–±–∫–∞: –§–∞–π–ª —Å–µ—Å—Å–∏–∏ {filename} –Ω–µ –Ω–∞–π–¥–µ–Ω"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
                return
            if not os.path.exists("./banned_sessions"):
                os.makedirs("./banned_sessions")
            shutil.move(session_path, banned_path)
            log_msg = f"–°–µ—Å—Å–∏—è {filename} –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ ./banned_sessions"
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
            json_filename = filename.replace('.session', '.json')
            source_json_path = session_path.replace(filename, json_filename)
            target_json_path = os.path.join("./banned_sessions", json_filename)
            if os.path.exists(source_json_path):
                shutil.move(source_json_path, target_json_path)
                log_msg = f"JSON-—Ñ–∞–π–ª {json_filename} –ø–µ—Ä–µ–º–µ—â—ë–Ω –≤ ./banned_sessions"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
            return
        except Exception as e:
            attempt += 1
            if attempt < max_attempts:
                await asyncio.sleep(2)
            else:
                log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Å–µ—Å—Å–∏—é {filename}: {str(e)}"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
async def create_channel_for_accounts(data, message, state: FSMContext):
    name = data.get("name")
    avatar = data.get("avatar")
    posts = data.get("posts", [])
    select = data.get("select", [])
    ses = [s for s in sessions if s.me and int(s.me.id) in select]
    if not ses:
        await message.edit_text("–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞.")
        await state.clear()
        await start(message)
        return
    
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º created_channels –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏, –µ—Å–ª–∏ –Ω–µ—Ç (—Ñ–∏–∫—Å KeyError)
    if selected_company not in created_channels:
        created_channels[selected_company] = []
    
    created_count = 0  # –û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ (—Å–æ–∑–¥–∞–Ω–∏—è + –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è)
    failed_sessions = []  # –î–ª—è –æ—à–∏–±–æ–∫ —Å retry
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äî —Ä–µ–ø–æ—Å—Ç –ø–æ—Å—Ç–æ–≤ + –∞–≤–∞—Ç–∞—Ä/–Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –≤—Å–µ—Ö
    if not posts:
        log_msg = f"–†–µ–ø–æ—Å—Ç –ø–æ—Å—Ç–æ–≤ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞/–Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤ (–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ)"
        rootLogger.info(log_msg)
        write_daily_log(log_msg)
        for session in ses:
            try:
                full_user = await session.app(functions.users.GetFullUserRequest(id=session.me.id))
                channel_id = full_user.full_user.personal_channel_id
                if channel_id:
                    channel_peer = types.PeerChannel(channel_id)
                    channel_entity = await session.app.get_entity(channel_peer)
                    # –ù–∞–∑–≤–∞–Ω–∏–µ
                    if channel_entity.title != name:
                        await session.app(functions.channels.EditTitleRequest(channel=channel_entity, title=name))
                        log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ '{name}' –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    # –ê–≤–∞—Ç–∞—Ä (–±–µ–∑ —Å–∂–∞—Ç–∏—è)
                    if avatar:
                        if isinstance(avatar, str):  # file_id from bot
                            file_info = await bot.get_file(avatar)
                            photo_bytes = await bot.download_file(file_info.file_path)
                        else:
                            photo_bytes = avatar
                        file = await session.app.upload_file(photo_bytes, file_name="avatar.jpg")
                        await session.app(functions.channels.EditPhotoRequest(channel=channel_entity, photo=file))
                        log_msg = f"–ê–≤–∞—Ç–∞—Ä –∫–∞–Ω–∞–ª–∞ {channel_id} –æ–±–Ω–æ–≤–ª—ë–Ω –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ø–æ—Å—Ç–æ–≤
                    async for msg in session.app.iter_messages(channel_id):
                        await session.app.delete_messages(channel_id, [msg.id])
                    log_msg = f"–°—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã —É–¥–∞–ª–µ–Ω—ã –∏–∑ {channel_id} –¥–ª—è {session.filename}"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
                    # –†–µ–ø–æ—Å—Ç –ø–æ—Å—Ç–æ–≤
                    donor_entity = await session.app.get_entity(data['link'])  # link —Å–æ—Ö—Ä–∞–Ω—ë–Ω –≤ state
                    message_ids = []
                    async for msg in session.app.iter_messages(donor_entity, limit=50):
                        if not isinstance(msg, types.MessageService):
                            message_ids.append(msg.id)
                    if message_ids:
                        forwarded = await session.app.forward_messages(channel_peer, message_ids, donor_entity)
                        log_msg = f"–†–µ–ø–æ—Å—Ç {len(forwarded)} –ø–æ—Å—Ç–æ–≤ –≤ {channel_id} –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    else:
                        log_msg = f"–ö–∞–Ω–∞–ª-–¥–æ–Ω–æ—Ä {data['link']} –ø—É—Å—Ç–æ–π, –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤ –¥–ª—è —Ä–µ–ø–æ—Å—Ç–∞ –≤ {channel_id}"
                        rootLogger.warning(log_msg)
                        write_daily_log(log_msg)
                    created_channels[selected_company].append({"id": channel_id, "name": name})
                    created_count += 1
                else:
                    log_msg = f"–£ {session.filename} –Ω–µ—Ç –ª–∏—á–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"
                    rootLogger.warning(log_msg)
                    write_daily_log(log_msg)
            except Exception as e:
                failed_sessions.append((session, str(e)))
                log_msg = f"–û—à–∏–±–∫–∞ —Ä–µ–ø–æ—Å—Ç–∞ –¥–ª—è {session.filename}: {str(e)}"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
    else:
        # –†–£–ß–ù–û–ô –í–í–û–î: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å —Ñ–∏–∫—Å–æ–º "file is too big" –¥–ª—è –∞–≤–∞—Ç–∞—Ä–∫–∏
        def convert_entities_to_html(text, entities):
            if not text or not entities:
                return text or ""
            result = text
            for entity in sorted(entities, key=lambda e: e.offset, reverse=True):
                start = entity.offset
                end = entity.offset + entity.length
                if end > len(text):
                    end = len(text)
                if start >= end or start >= len(text) or start < 0:
                    continue
                entity_text = result[start:end]
                if entity.type == "bold":
                    replacement = f"<b>{entity_text}</b>"
                elif entity.type == "italic":
                    replacement = f"<i>{entity_text}</i>"
                elif entity.type == "spoiler":
                    replacement = f"<spoiler>{entity_text}</spoiler>"
                elif entity.type == "code":
                    replacement = f"<code>{entity_text}</code>"
                elif entity.type == "pre":
                    replacement = f"<pre>{entity_text}</pre>"
                elif entity.type == "underline":
                    replacement = f"<u>{entity_text}</u>"
                elif entity.type == "strikethrough":
                    replacement = f"<s>{entity_text}</s>"
                elif entity.type == "text_link":
                    url = entity.url
                    replacement = f'<a href="{url}">{entity_text}</a>'
                elif entity.type == "text_mention":
                    user_id = entity.user.id if hasattr(entity, 'user') and entity.user else entity_text
                    replacement = f'<a href="tg://user?id={user_id}">{entity_text}</a>'
                elif entity.type == "url":
                    replacement = f'<a href="{entity_text}">{entity_text}</a>'
                else:
                    rootLogger.warning(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø entity: {entity.type}, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º")
                    continue
                result = result[:start] + replacement + result[end:]
            return result
        
        for session in ses:
            max_retries = 2
            retry_count = 0
            success = False
            last_error = None
            while retry_count < max_retries and not success:
                try:
                    if not session.app.is_connected():
                        log_msg = f"–ö–ª–∏–µ–Ω—Ç –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename} –Ω–µ –ø–æ–¥–∫–ª—é—á—ë–Ω, –ø—ã—Ç–∞–µ–º—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å"
                        rootLogger.warning(log_msg)
                        write_daily_log(log_msg)
                        await session.app.connect()
                    full_user = await session.app(functions.users.GetFullUserRequest(id=session.me.id))
                    channel_id = full_user.full_user.personal_channel_id
                    if channel_id:
                        log_msg = f"–°–µ—Å—Å–∏—è {session.filename}: —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–∞–Ω–∞–ª {channel_id}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        channel_entity = await session.app.get_entity(types.PeerChannel(channel_id))
                        if channel_entity.title != name:
                            try:
                                await session.app(functions.channels.EditTitleRequest(
                                    channel=channel_entity,
                                    title=name
                                ))
                                log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} –∏–∑–º–µ–Ω–µ–Ω–æ –Ω–∞ '{name}' –¥–ª—è {session.filename}"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                            except ForbiddenError as e:
                                if "The chat or channel wasn't modified" in str(e):
                                    log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} —É–∂–µ '{name}', –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –¥–ª—è {session.filename}"
                                    rootLogger.info(log_msg)
                                    write_daily_log(log_msg)
                                else:
                                    raise
                        else:
                            log_msg = f"–ù–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ {channel_id} —É–∂–µ '{name}', –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ –¥–ª—è {session.filename}"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                        if avatar:
                            if isinstance(avatar, str):  # file_id from bot
                                file_info = await bot.get_file(avatar)
                                photo_bytes = await bot.download_file(file_info.file_path)
                            else:  # bytes
                                photo_bytes = avatar
                            file = await session.app.upload_file(photo_bytes, file_name="avatar.jpg")
                            await session.app(functions.channels.EditPhotoRequest(
                                channel=channel_entity,
                                photo=file
                            ))
                            log_msg = f"–ê–≤–∞—Ç–∞—Ä–∫–∞ –∫–∞–Ω–∞–ª–∞ {channel_id} –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è {session.filename}"
                            rootLogger.info(log_msg)
                            write_daily_log(log_msg)
                        async for msg in session.app.iter_messages(channel_id):
                            try:
                                await session.app.delete_messages(channel_id, [msg.id])
                            except Exception as e:
                                log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è {msg.id} –≤ –∫–∞–Ω–∞–ª–µ {channel_id}: {str(e)}"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                        log_msg = f"–í—Å–µ —Å—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã —É–¥–∞–ª–µ–Ω—ã –∏–∑ –∫–∞–Ω–∞–ª–∞ {channel_id} –¥–ª—è {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        for post in posts:
                            if post['type'] == 'text':
                                formatted_text = convert_entities_to_html(post['content'], post['entities'])
                                await session.app.send_message(channel_id, formatted_text, parse_mode='html')
                            elif post['type'] in ['photo', 'video']:
                                if 'media_bytes' in post:  # From copy
                                    media_bytes = post['media_bytes']
                                else:  # file_id from bot
                                    file_info = await bot.get_file(post['file_id'])
                                    media_bytes = await bot.download_file(file_info.file_path)
                                file_name = f"media.{post['type']}"
                                file = await session.app.upload_file(media_bytes, file_name=file_name)
                                formatted_caption = convert_entities_to_html(post['caption'], post['entities'])
                                await session.app.send_message(channel_id, formatted_caption, file=file, parse_mode='html')
                            elif post['type'] == 'album':
                                files = []
                                for photo in post['photos']:
                                    if 'media_bytes' in photo:
                                        media_bytes = photo['media_bytes']
                                    else:
                                        file_info = await bot.get_file(photo['file_id'])
                                        media_bytes = await bot.download_file(file_info.file_path)
                                    file = await session.app.upload_file(media_bytes, file_name="media.jpg")
                                    files.append(file)
                                formatted_caption = convert_entities_to_html(post['photos'][0]['caption'], post['photos'][0]['entities'])
                                await session.app.send_file(channel_id, files, caption=formatted_caption, parse_mode='html')
                        log_msg = f"–ö–∞–Ω–∞–ª {channel_id} –æ–±–Ω–æ–≤–ª—ë–Ω –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename}: –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ '{name}', –¥–æ–±–∞–≤–ª–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        created_channels[selected_company].append({"id": channel_id, "name": name})
                        created_count += 1
                    else:  # –ù–æ–≤—ã–π –∫–∞–Ω–∞–ª
                        log_msg = f"–°–µ—Å—Å–∏—è {session.filename}: —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        channel = await session.app(functions.channels.CreateChannelRequest(
                            title=name,
                            about="–°–æ–∑–¥–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏",
                            megagroup=False
                        ))
                        channel_entity = channel.chats[0]
                        channel_id = channel_entity.id
                        if avatar:
                            if isinstance(avatar, str):
                                file_info = await bot.get_file(avatar)
                                photo_bytes = await bot.download_file(file_info.file_path)
                            else:
                                photo_bytes = avatar
                            file = await session.app.upload_file(photo_bytes, file_name="avatar.jpg")
                            await session.app(functions.channels.EditPhotoRequest(
                                channel=channel_id,
                                photo=file
                            ))
                        for post in posts:
                            if post['type'] == 'text':
                                formatted_text = convert_entities_to_html(post['content'], post['entities'])
                                await session.app.send_message(channel_id, formatted_text, parse_mode='html')
                            elif post['type'] in ['photo', 'video']:
                                if 'media_bytes' in post:
                                    media_bytes = post['media_bytes']
                                else:
                                    file_info = await bot.get_file(post['file_id'])
                                    media_bytes = await bot.download_file(file_info.file_path)
                                file_name = f"media.{post['type']}"
                                file = await session.app.upload_file(media_bytes, file_name=file_name)
                                formatted_caption = convert_entities_to_html(post['caption'], post['entities'])
                                await session.app.send_message(channel_id, formatted_caption, file=file, parse_mode='html')
                            elif post['type'] == 'album':
                                files = []
                                for photo in post['photos']:
                                    if 'media_bytes' in photo:
                                        media_bytes = photo['media_bytes']
                                    else:
                                        file_info = await bot.get_file(photo['file_id'])
                                        media_bytes = await bot.download_file(file_info.file_path)
                                    file = await session.app.upload_file(media_bytes, file_name="media.jpg")
                                    files.append(file)
                                formatted_caption = convert_entities_to_html(post['photos'][0]['caption'], post['photos'][0]['entities'])
                                await session.app.send_file(channel_id, files, caption=formatted_caption, parse_mode='html')
                        base_username = "".join(TRANS_TABLE.get(c, c) for c in name.lower() if c.isalnum() or c in TRANS_TABLE)
                        username = f"{base_username[:20]}{session.me.id % 10000}"
                        i = 0
                        username_set = False
                        while i < 5:
                            try:
                                await session.app(functions.channels.UpdateUsernameRequest(
                                    channel=channel_entity,
                                    username=username
                                ))
                                username_set = True
                                log_msg = f"Username {username} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è –∫–∞–Ω–∞–ª–∞ {channel_id} –≤ —Å–µ—Å—Å–∏–∏ {session.filename}"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                                break
                            except FloodWaitError as e:
                                log_msg = f"–û–∂–∏–¥–∞–Ω–∏–µ {e.seconds} —Å–µ–∫—É–Ω–¥ –∏–∑-–∑–∞ FloodWait –¥–ª—è {session.filename}"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                await asyncio.sleep(e.seconds)
                            except UsernameOccupiedError:
                                i += 1
                                username = f"{base_username[:20]}{session.me.id % 10000}{i}"
                                log_msg = f"Username {username[:-1]} –∑–∞–Ω—è—Ç, –ø—Ä–æ–±—É–µ–º {username}"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                            except Exception as e:
                                log_msg = f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ username –¥–ª—è {session.filename}: {str(e)}"
                                rootLogger.error(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                break
                        if username_set:
                            try:
                                await session.app(functions.account.UpdatePersonalChannelRequest(channel=channel_entity))
                                log_msg = f"–ö–∞–Ω–∞–ª {username} —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω –∫–∞–∫ –ª–∏—á–Ω—ã–π –¥–ª—è {session.filename}"
                                rootLogger.info(log_msg)
                                write_daily_log(log_msg)
                            except FloodWaitError as e:
                                log_msg = f"FloodWait –ø—Ä–∏ –ø—Ä–∏–≤—è–∑–∫–µ –∫–∞–Ω–∞–ª–∞ {username} –¥–ª—è {session.filename}: –∂–¥—ë–º {e.seconds} —Å–µ–∫—É–Ω–¥"
                                rootLogger.warning(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                                await asyncio.sleep(e.seconds)
                                continue
                            except Exception as e:
                                log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏–≤—è–∑–∫–∏ –∫–∞–Ω–∞–ª–∞ {username} –¥–ª—è {session.filename}: {str(e)}"
                                rootLogger.error(log_msg)
                                write_daily_log(log_msg)
                                await bot.send_message(chat_id, log_msg)
                        channel_link = f"https://t.me/{username}" if username_set else f"–ö–∞–Ω–∞–ª {channel_id} (–ø—Ä–∏–≤–∞—Ç–Ω—ã–π)"
                        log_msg = f"–ö–∞–Ω–∞–ª '{name}' —Å–æ–∑–¥–∞–Ω –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename} —Å ID {channel_id} –ø–æ —Å—Å—ã–ª–∫–µ {channel_link}, –¥–æ–±–∞–≤–ª–µ–Ω–æ {len(posts)} –ø–æ—Å—Ç–æ–≤"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                        created_channels[selected_company].append({"id": channel_id, "name": name})
                        created_count += 1
                    success = True
                except Exception as e:
                    retry_count += 1
                    last_error = str(e)
                    rootLogger.warning(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –¥–ª—è {session.filename} (–ø–æ–ø—ã—Ç–∫–∞ {retry_count}/{max_retries}): {str(e)}")
                    if retry_count < max_retries:
                        await asyncio.sleep(5)
                    else:
                        failed_sessions.append((session, last_error))
                        log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –∫–∞–Ω–∞–ª –¥–ª—è {session.filename} –ø–æ—Å–ª–µ {max_retries} –ø–æ–ø—ã—Ç–æ–∫: {last_error}"
                        rootLogger.error(log_msg)
                        write_daily_log(log_msg)
                        await bot.send_message(chat_id, log_msg)
    
    # –û–±—â–∏–π –∫–æ–¥ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–¥–ª—è –æ–±–æ–∏—Ö —Å–ª—É—á–∞–µ–≤)
    with open(f"./companies/{selected_company}/created_channels.json", "w", encoding="utf-8") as file:
        json.dump(created_channels[selected_company], file, ensure_ascii=False)
    log_msg = f"–°–æ–∑–¥–∞–Ω–∏–µ/–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ {created_count} –∏–∑ {len(ses)} –∞–∫–∫–∞—É–Ω—Ç–æ–≤."
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    await bot.send_message(chat_id, log_msg)
    await message.edit_text(f"–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: {created_count} –∏–∑ {len(ses)}")
    for failed_session, error in failed_sessions:
        error_msg = f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ –¥–ª—è {failed_session.filename}: {error}"
        await bot.send_message(chat_id, error_msg)
        rootLogger.error(error_msg)
    await state.clear()
    await start(message)
async def apply_data(callback: atypes.CallbackQuery, state: FSMContext, change: str = ""):
    data = await state.get_data()
    select = data.get("select", [])
    change = data.get("change", change)
    value = data.get("value", None) if change != "delete_avatar" else None
    ses = [s for s in sessions if s.me and int(s.me.id) in select]
    if not ses:
        await callback.message.edit_text("–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∞–∫–∫–∞—É–Ω—Ç–æ–≤ –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π.")
        await state.clear()
        await start(callback.message)
        return
    rootLogger.info(f"–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è '{change}' –¥–ª—è {len(ses)} —Å–µ—Å—Å–∏–π")
    async def apply_to_session(session):
        try:
            if change == "fname":
                me = await session.app.get_me()
                current_last_name = me.last_name if me.last_name else ""
                await session.app(functions.account.UpdateProfileRequest(
                    first_name=value,
                    last_name=current_last_name
                ))
                log_msg = f"–ò–º—è –∏–∑–º–µ–Ω–µ–Ω–æ –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename}: {value}"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
            elif change == "lname":
                me = await session.app.get_me()
                current_first_name = me.first_name if me.first_name else ""
                await session.app(functions.account.UpdateProfileRequest(
                    first_name=current_first_name,
                    last_name=value
                ))
                log_msg = f"–§–∞–º–∏–ª–∏—è –∏–∑–º–µ–Ω–µ–Ω–∞ –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename}: {value}"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
            elif change == "bio":
                await session.app(functions.account.UpdateProfileRequest(
                    first_name=session.me.first_name if session.me.first_name else "",
                    last_name=session.me.last_name if session.me.last_name else "",
                    about=value
                ))
                log_msg = f"–ë–∏–æ –∏–∑–º–µ–Ω–µ–Ω–æ –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename}: {value}"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
            elif change == "avatar":
                if isinstance(value, bytes):
                    with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as temp_file:
                        temp_file.write(value)
                        temp_file_path = temp_file.name
                    try:
                        photo = await session.app.upload_file(temp_file_path)
                        await session.app(functions.photos.UploadProfilePhotoRequest(file=photo))
                        log_msg = f"–ê–≤–∞—Ç–∞—Ä –æ–±–Ω–æ–≤–ª—ë–Ω –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename}"
                        rootLogger.info(log_msg)
                        write_daily_log(log_msg)
                    finally:
                        os.remove(temp_file_path)
                else:
                    raise ValueError("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∞–≤–∞—Ç–∞—Ä–∞")
            elif change == "delete_avatar":
                photos = await session.app(functions.photos.GetUserPhotosRequest(
                    user_id=await session.app.get_input_entity(session.me.id),
                    offset=0,
                    max_id=0,
                    limit=100
                ))
                if isinstance(photos, types.photos.Photos) and photos.photos:
                    photo_ids = [types.InputPhoto(
                        id=photo.id,
                        access_hash=photo.access_hash,
                        file_reference=photo.file_reference
                    ) for photo in photos.photos]
                    await session.app(functions.photos.DeletePhotosRequest(id=photo_ids))
                    log_msg = f"–í—Å–µ —Ñ–æ—Ç–æ —É–¥–∞–ª–µ–Ω—ã –¥–ª—è —Å–µ—Å—Å–∏–∏ {session.filename}"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
                else:
                    log_msg = f"–ù–µ—Ç —Ñ–æ—Ç–æ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤ –ø—Ä–æ—Ñ–∏–ª–µ —Å–µ—Å—Å–∏–∏ {session.filename}"
                    rootLogger.info(log_msg)
                    write_daily_log(log_msg)
            elif change == "story_reactions":
                log_msg = f"–†–µ–∞–∫—Ü–∏–∏ –¥–ª—è {session.filename} –æ–±–Ω–æ–≤–ª–µ–Ω—ã –Ω–∞ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫"
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
        except Exception as e:
            raise e
    tasks = [apply_to_session(session) for session in ses]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    successful_updates = 0
    for session, result in zip(ses, results):
        if isinstance(result, Exception):
            log_msg = f"–û–®–ò–ë–ö–ê: –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è {session.filename}: {str(result)}"
            rootLogger.error(log_msg)
            write_daily_log(log_msg)
            await bot.send_message(chat_id, log_msg)
        else:
            successful_updates += 1
    report_text = f"–î–µ–π—Å—Ç–≤–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∫ {successful_updates} {'—Å–µ—Å—Å–∏–∏' if successful_updates == 1 else '—Å–µ—Å—Å–∏—è–º'} –∏–∑ {len(ses)}"
    max_attempts = 1
    attempt = 0
    while attempt < max_attempts:
        try:
            current_message = await bot.get_messages(callback.message.chat.id, callback.message.message_id)
            if current_message.text != report_text:
                await callback.message.edit_text(report_text)
            break
        except Exception as e:
            if "message is not modified" in str(e).lower():
                break
            attempt += 1
            if attempt < max_attempts:
                await asyncio.sleep(3)
            else:
                log_msg = f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á—ë—Ç: {str(e)}"
                rootLogger.error(log_msg)
                write_daily_log(log_msg)
                await bot.send_message(chat_id, log_msg)
    await callback.answer()
    await state.clear()
    await start(callback.message)
async def check_account_frozen(client: TelegramClient) -> bool:
    """
    Checking whether account if frozen
    :param client: Telegram client
    :return: True if frozen, false otherwise
    """
    try:
        await client.send_message(FROZE_CHECK_BOT_USERNAME, "/start")
    except Exception as e:
        print(e)
        return True
    await client.delete_dialog(FROZE_CHECK_BOT_USERNAME)
    return False
async def handle_spam_block(client: TelegramClient):
    me = await client.get_me()
    filtered_sessions = list(filter(lambda x: x.me is not None and x.me.id == me.id, sessions))
    if not filtered_sessions:
        log_msg = f"–°–µ—Å—Å–∏—è –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞ —Å ID {me.id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        return None, None
    session: Session = filtered_sessions[0]
    if not hasattr(session, 'last_spam_check'):
        session.last_spam_check = None
    if not hasattr(session, 'spam_check_cooldown'):
        session.spam_check_cooldown = 300
    current_time = datetime.now(pytz.UTC)
    if session.last_spam_check and (current_time - session.last_spam_check).total_seconds() < session.spam_check_cooldown:
        log_msg = f"–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Å—Å–∏–∏ {session.filename} –Ω–∞ –ø–∞—É–∑–µ (cooldown)"
        rootLogger.debug(log_msg)
        write_daily_log(log_msg)
        return None, None
    try:
        is_frozen = await check_account_frozen(client)
        if is_frozen:
            session.blocked = True
            session.unblocked_at = None
            return "–∫—Ä–∞—Å–Ω—ã–π", "–∑–∞–º–æ—Ä–æ–∂–µ–Ω"
        return "–∑–µ–ª—ë–Ω—ã–π", None
    except Exception as e:
        if "Request was unsuccessful" in str(e) and attempt < max_attempts - 1:
            await asyncio.sleep(5)
        else:
            log_msg = f"–°–µ—Å—Å–∏—è {session.filename} –Ω–µ —Å–º–æ–≥–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–ø–∞–º-–±–ª–æ–∫: {str(e)}"
            rootLogger.error(log_msg)
            write_daily_log(log_msg)
            return "–∂—ë–ª—Ç—ã–π", "–æ—à–∏–±–∫–∞"
async def on_spambot_message(event):
    client = event.client
    message = event.message
    await handle_spam_block(client)
    me = await client.get_me()
    session = next((s for s in sessions if s.me is not None and s.me.id == me.id), None)
    if session and session.blocked and not session.sent_appelation:
        if isinstance(message.reply_markup, types.ReplyKeyboardMarkup):
            if len(message.reply_markup.rows) == 4:
                await client.send_message(178220800, message.reply_markup.rows[3][0].text)
            if len(message.reply_markup.rows) == 2:
                await client.send_message(178220800, message.reply_markup.rows[0][0].text)
            session.sent_appelation = True
async def collect_created_views_stats(message: atypes.Message):
    ses = [s for s in sessions if s.me and s.company == selected_company]
    if not ses:
        await message.reply(f"–í –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company} –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π.")
        return
   
    stats_report = []
    total_channels = 0
    total_views_all = 0
    for session in ses:
        try:
            full_user = await session.app(functions.users.GetFullUserRequest(id=session.me.id))
            channel_id = full_user.full_user.personal_channel_id
            if not channel_id:
                log_msg = f"–£ –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename} –Ω–µ—Ç –ø—Ä–∏–≤—è–∑–∞–Ω–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞."
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
                continue
            channel_entity = await session.app.get_entity(types.PeerChannel(channel_id))
            channel_username = f"@{channel_entity.username}" if channel_entity.username else f"t.me/c/{channel_id}"
            messages = []
            async for msg in session.app.iter_messages(channel_id, limit=10):
                if msg.views is not None:
                    messages.append({
                        "views": msg.views
                    })
           
            if not messages:
                log_msg = f"–í –∫–∞–Ω–∞–ª–µ (ID {channel_id}) –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤ —Å –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º–∏ –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename}."
                rootLogger.info(log_msg)
                write_daily_log(log_msg)
                continue
            total_views = sum(msg["views"] for msg in messages)
            total_views_all += total_views
            total_channels += 1
            stats_report.append(f"–°–µ—Å—Å–∏—è {session.filename}: {channel_username}, –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤: {total_views}")
            log_msg = f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–æ–±—Ä–∞–Ω–∞ –¥–ª—è –∫–∞–Ω–∞–ª–∞ {channel_username} (ID {channel_id}): {len(messages)} –ø–æ—Å—Ç–æ–≤, {total_views} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤ (–∞–∫–∫–∞—É–Ω—Ç {session.filename})."
            rootLogger.info(log_msg)
            write_daily_log(log_msg)
        except Exception as e:
            log_msg = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è –∞–∫–∫–∞—É–Ω—Ç–∞ {session.filename}: {str(e)}"
            rootLogger.error(log_msg)
            write_daily_log(log_msg)
            await bot.send_message(chat_id, log_msg)
            continue
    if not stats_report:
        await message.reply(f"–ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ —Å –ø–æ—Å—Ç–∞–º–∏ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}.")
        return
    stats_report.append(f"–ò—Ç–æ–≥: –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤: {total_views_all}")
    report_text = "\n".join(stats_report)
    await message.reply(report_text)
    log_msg = f"–°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º –∑–∞–≤–µ—Ä—à—ë–Ω –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}: {total_channels} –∫–∞–Ω–∞–ª–æ–≤, {total_views_all} –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤."
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    await bot.send_message(chat_id, log_msg)
# –ë–æ—Ç–æ–≤—Å–∫–æ–µ
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "back_to_start"))
async def back_to_start(callback: atypes.CallbackQuery):
    global selected_company
    if selected_company is None:
        kb_companies = atypes.InlineKeyboardMarkup(inline_keyboard=[
            *[atypes.InlineKeyboardButton(text=x, callback_data="sel_company_" + x) for x in listdir("./companies")],
            [atypes.InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –∫–æ–º–ø–∞–Ω–∏—é", callback_data="create_company")],
            [atypes.InlineKeyboardButton(text="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="account_stats")]
        ])
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é:", reply_markup=kb_companies)
    else:
        async with stats_lock:
            stats_text = get_stats_text(selected_company)
        msg = await callback.message.edit_text(stats_text, reply_markup=kb_menu)
        asyncio.create_task(update_stats_message(msg.chat.id, msg.message_id, selected_company))
    await callback.answer()
@dp.message((F.from_user.id == owner_id) & (F.text == "/stats_all"))
async def stats_all(message: atypes.Message):
    stats = get_all_stats()
    await message.reply(stats)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "collect_created_views_stats"))
async def start_collect_views_stats(callback: atypes.CallbackQuery):
    if not selected_company:
        await callback.message.edit_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é.")
        await callback.answer()
        return
    await callback.answer()
    msg = await callback.message.edit_text("–°–±–æ—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–º –∫–∞–Ω–∞–ª–∞–º –Ω–∞—á–∞–ª—Å—è...")
    await collect_created_views_stats(msg)
    await start(callback.message)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "back_to_menu"))
async def back_to_menu(callback: atypes.CallbackQuery):
    async with stats_lock:
        stats_text = get_stats_text(selected_company) # –£–∂–µ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
    msg = await callback.message.edit_text(stats_text, reply_markup=kb_menu)
    asyncio.create_task(update_stats_message(msg.chat.id, msg.message_id, selected_company))
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "back_to_change"))
async def back_to_change(callback: atypes.CallbackQuery):
    async with stats_lock:
        stats_text = get_stats_text(selected_company)
    msg = await callback.message.edit_text(stats_text, reply_markup=kb_change_settings)
    asyncio.create_task(update_stats_message(msg.chat.id, msg.message_id, selected_company))
    await callback.answer()
@dp.message((F.from_user.id == owner_id) & (F.text == "/start"))
async def start(message: atypes.Message):
    global selected_company
    log_msg = f"–ó–∞–ø—É—Å–∫ –∫–æ–º–∞–Ω–¥—ã /start. –¢–µ–∫—É—â–∞—è –∫–æ–º–ø–∞–Ω–∏—è: {selected_company}"
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions)) if selected_company else []
    log_msg = f"–ù–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}: {len(ses)}"
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    if selected_company is None:
        kb_companies = atypes.InlineKeyboardMarkup(inline_keyboard=list(
            map(lambda x: [atypes.InlineKeyboardButton(text=x, callback_data="sel_company_" + x)],
                list(listdir("./companies"))
                )) + [[atypes.InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –∫–æ–º–ø–∞–Ω–∏—é", callback_data="create_company")],
                      [atypes.InlineKeyboardButton(text="–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–æ–≤", callback_data="account_stats")]])
        await message.reply("–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é:", reply_markup=kb_companies)
    else:
        await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:", reply_markup=kb_menu)
def make_stat_str(session):
    blocked = "‚ò¢Ô∏è –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω" if session.blocked else f"‚ö†Ô∏è –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –≤ {session.unblocked_at}" if session.unblocked_at else "üóí –ñ–¥—ë—Ç –∞–ø–µ–ª–ª—è—Ü–∏–∏" if session.sent_appelation else "‚úÖ –°–≤–æ–±–æ–¥–µ–Ω"
    username = session.me.username if session.me.username else session.me.phone_number if session.me.phone_number else session.me.id
    premium = "‚úÖ –ï—Å—Ç—å –ø—Ä–µ–º–∏—É–º" if session.me.is_premium else "‚ùå –ù–µ—Ç –ø—Ä–µ–º–∏—É–º–∞"
    return f"{session.filename} - {blocked} - {username} - {premium} - –õ–∞–π–∫–æ–≤ —Å—Ç–æ—Ä–∏—Å —Å–µ–≥–æ–¥–Ω—è: {session.story_likes_today}"
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "account_stats"))
async def account_stat(callback: atypes.CallbackQuery):
    text = list(map(make_stat_str, list(
        filter(lambda x: x.me is not None and x.company == selected_company if selected_company else True,
               sessions)))) + ["‚õîÔ∏è –û—Ç–∫–ª—é—á–µ–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã: " + ", ".join(
        list(map(lambda x: x.filename, list(filter(lambda x: x.me is None, sessions)))))]
    await callback.message.edit_text("\n".join(text))
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "create_company"))
async def create_company(callback: atypes.CallbackQuery, state: FSMContext):
    await state.set_state(CreateCompanyState.name)
    await callback.message.edit_text("–ù–∞–ø–∏—à–∏—Ç–µ –∏–º—è –∫–æ–º–ø–∞–Ω–∏–∏")
@dp.message(CreateCompanyState.name, (F.from_user.id == owner_id))
async def set_name(message: atypes.Message, state: FSMContext):
    global selected_company
    await state.clear()
    selected_company = message.text.lower()
    os.makedirs(f"./companies/{selected_company}/sessions")
    company_configs[selected_company] = {}
    company_stats[selected_company] = {
        "stories_viewed": 0,
        "likes_set": 0,
        "unique_users": set(),
        "channels_processed": 0,
        "chats_processed": 0,
        "unique_users_with_stories": set()
    }
    stats_file = f"./companies/{selected_company}/company_stats.json"
    with open(stats_file, "w", encoding='utf-8') as f:
        json.dump({
            "stories_viewed": 0,
            "likes_set": 0,
            "unique_users": [],
            "channels_processed": 0,
            "chats_processed": 0,
            "unique_users_with_stories": []
        }, f, ensure_ascii=False)
    await message.reply("–ö–æ–º–ø–∞–Ω–∏—è —Å–æ–∑–¥–∞–Ω–∞, –¥–æ–±–∞–≤—å—Ç–µ —Å–µ—Å—Å–∏–∏ –∏ –∫–∞–Ω–∞–ª—ã")
    await start(message)
def create_companies_keyboard(selected_companies: set):
    builder = InlineKeyboardBuilder()
    for company in company_configs.keys():
        is_selected = company in selected_companies
        builder.row(atypes.InlineKeyboardButton(
            text=f"{'‚úÖ' if is_selected else '‚ùå'} {company}",
            callback_data=f"select_company_{company}"
        ))
    builder.row(atypes.InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="select_companies_done"))
    builder.row(atypes.InlineKeyboardButton(text="–ó–∞–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ", callback_data="select_all_companies"))
    return builder.as_markup()
@dp.callback_query((F.from_user.id == owner_id) & (F.data.startswith("select_company_")))
async def handle_company_selection(callback: atypes.CallbackQuery):
    company = callback.data.replace("select_company_", "")
    selected_companies = set()
    await callback.message.edit_reply_markup(
        reply_markup=create_companies_keyboard(selected_companies)
    )
    await switch_company(callback, company)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "select_companies_done"))
async def finish_company_selection(callback: atypes.CallbackQuery):
    await callback.message.edit_text("–í—ã–±–æ—Ä –∫–æ–º–ø–∞–Ω–∏–π –∑–∞–≤–µ—Ä—à—ë–Ω.")
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "select_all_companies"))
async def select_all_companies(callback: atypes.CallbackQuery):
    selected_companies = set(company_configs.keys())
    await callback.message.edit_reply_markup(
        reply_markup=create_companies_keyboard(selected_companies)
    )
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data.startswith("sel_company_")))
async def select_company(callback: atypes.CallbackQuery):
    global selected_company
    company = callback.data[12:]
    if not path.exists(f"./companies/{company}"):
        return await callback.message.edit_text("–í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–æ–º–ø–∞–Ω–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
    selected_company = company
    async with stats_lock:
        stats_text = get_stats_text(selected_company)
    msg = await callback.message.edit_text(stats_text, reply_markup=kb_menu)
    asyncio.create_task(update_stats_message(msg.chat.id, msg.message_id, selected_company))
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "add_channel"))
async def start_add_channel(callback: atypes.CallbackQuery, state: FSMContext):
    await state.set_state(AddPrivateChannelState.name)
    await callback.message.edit_text("–ö–∞–∫ –Ω–∞–∑–≤–∞—Ç—å –∫–∞–Ω–∞–ª?")
    await callback.answer()
@dp.message(AddPrivateChannelState.name, (F.from_user.id == owner_id))
async def set_channel_name(message: atypes.Message, state: FSMContext):
    text = message.text.strip()
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å—Å—ã–ª–∫—É –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è (@username, t.me/username, https://t.me/username)
    link_match = re.match(r'(?:https?://t\.me/|t\.me/|@)?([a-zA-Z0-9_]+)', text)
    if link_match:
        link = link_match.group(0)
        if not link.startswith('http'):
            link = f"https://t.me/{link}" if not link.startswith('t.me/') else link
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤—É—é —Å–µ—Å—Å–∏—é –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è (–ª—é–±–æ–π –∞–∫–∫–∞—É–Ω—Ç)
        session = next((s for s in sessions if s.me and s.company == selected_company), None)
        if not session:
            await message.reply("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞.")
            return
        await message.reply("–ö–æ–ø–∏—Ä—É—é –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞...")
        copied_data = await copy_channel_data(session, link)
        if copied_data:
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ, –∞–≤–∞—Ç–∞—Ä=None (–∑–∞–ø—Ä–æ—Å–∏–º –ø–æ–∑–∂–µ), posts=[] (—Ä–µ–ø–æ—Å—Ç –ø–æ–∑–∂–µ –¥–ª—è –≤—Å–µ—Ö)
            await state.update_data(
                name=copied_data['name'],
                avatar=None,  # –ó–∞–ø—Ä–æ—Å–∏–º —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                posts=[],  # –†–µ–ø–æ—Å—Ç –ø–æ–∑–∂–µ
                link=link  # –°–æ—Ö—Ä–∞–Ω—è–µ–º link –¥–ª—è —Ä–µ–ø–æ—Å—Ç–∞ –≤ create_channel_for_accounts
            )
            await message.reply(f"–ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ: –Ω–∞–∑–≤–∞–Ω–∏–µ '{copied_data['name']}'. –¢–µ–ø–µ—Ä—å –ø—Ä–∏—à–ª–∏ –∞–≤–∞—Ç–∞—Ä–∫—É –∏–ª–∏ –Ω–∞–ø–∏—à–∏ '–Ω–µ—Ç'.")
            await state.set_state(AddPrivateChannelState.avatar)  # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –∑–∞–ø—Ä–æ—Å—É –∞–≤–∞—Ç–∞—Ä–∞
            return
        else:
            await message.reply(f"–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ {link}. –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—Ä—É—á–Ω—É—é.")
    else:
        # –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º: set name ‚Üí avatar (—Ä—É—á–Ω–æ–π –≤–≤–æ–¥)
        await state.update_data(name=text)
        await state.set_state(AddPrivateChannelState.avatar)
        await message.reply("–ö–∞–∫–æ–π –±—É–¥–µ—Ç –∞–≤–∞—Ç–∞—Ä–∫–∞? –ü—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ –∏–ª–∏ –Ω–∞–ø–∏—à–∏ '–Ω–µ—Ç'.")

@dp.message(AddPrivateChannelState.avatar, (F.from_user.id == owner_id))
async def set_channel_avatar(message: atypes.Message, state: FSMContext):
    data = await state.get_data()
    if message.content_type == 'photo':
        avatar = message.photo[-1].file_id
    elif message.content_type == 'document' and message.document.mime_type.startswith('image/'):
        avatar = message.document.file_id
    else:
        if message.text and message.text.lower() in ['–Ω–µ—Ç', '/done']:  # –§–∏–∫—Å: /done –∏–ª–∏ '–Ω–µ—Ç' = –ø—Ä–æ–ø—É—Å–∫
            avatar = None
        else:
            await message.reply("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ '–Ω–µ—Ç'.")
            return
    await state.update_data(avatar=avatar)
    await state.set_state(AddPrivateChannelState.posts)
    await state.update_data(posts=[])
    if 'link' in data:  # –ï—Å–ª–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ (–µ—Å—Ç—å link) ‚Äî —Å—Ä–∞–∑—É –∫ select
        await state.set_state(AddPrivateChannelState.select)
        ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
        await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞:", reply_markup=kb_all_or_select)
    else:
        await message.reply("–û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –ø–æ—Å—Ç—ã –¥–ª—è –∫–∞–Ω–∞–ª–∞ (—Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ). –ó–∞–≤–µ—Ä—à–∏—Ç–µ –∫–æ–º–∞–Ω–¥–æ–π /done.")

@dp.message(AddPrivateChannelState.posts, (F.from_user.id == owner_id))
async def add_channel_post(message: atypes.Message, state: FSMContext):
    if message.text and message.text.lower() == '/done':
        data = await state.get_data()
        posts = data.get('posts', [])
        if not posts:
            await message.reply("–í—ã –Ω–µ –¥–æ–±–∞–≤–∏–ª–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ –ø–æ—Å—Ç–∞.")
            return
        await state.set_state(AddPrivateChannelState.select)
        ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
        await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞:", reply_markup=kb_all_or_select)
        return
   
    data = await state.get_data()
    posts = data.get('posts', [])
    media_groups = data.get('media_groups', {})
    if message.media_group_id:
        if message.media_group_id not in media_groups:
            media_groups[message.media_group_id] = []
        media_groups[message.media_group_id].append({
            'file_id': message.photo[-1].file_id,
            'caption': message.caption or '' if not media_groups[message.media_group_id] else '',
            'entities': message.caption_entities or [] if not media_groups[message.media_group_id] else []
        })
        if len(media_groups[message.media_group_id]) == 1:
            posts.append({'type': 'album', 'photos': media_groups[message.media_group_id]})
    elif message.content_type == 'text':
        posts.append({'type': 'text', 'content': message.text, 'entities': message.entities or []})
    elif message.content_type == 'photo':
        posts.append({'type': 'photo', 'file_id': message.photo[-1].file_id, 'caption': message.caption or '', 'entities': message.caption_entities or []})
    elif message.content_type == 'video':
        posts.append({'type': 'video', 'file_id': message.video.file_id, 'caption': message.caption or '', 'entities': message.caption_entities or []})
    else:
        await message.reply("–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ –∏ –≤–∏–¥–µ–æ.")
        return
   
    await state.update_data(posts=posts, media_groups=media_groups)
    await message.reply("–ü–æ—Å—Ç –¥–æ–±–∞–≤–ª–µ–Ω. –î–æ–±–∞–≤—å—Ç–µ –µ—â—ë –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Å /done.")
@dp.callback_query(AddPrivateChannelState.select, (F.from_user.id == owner_id) & (F.data.in_({"select_all", "select_selective"})))
async def select_channel_accounts(callback: atypes.CallbackQuery, state: FSMContext):
    global sessions, selected_company
    data = await state.get_data()
    ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
    if not ses:
        await callback.message.edit_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è —ç—Ç–æ–π –∫–æ–º–ø–∞–Ω–∏–∏.")
        await state.clear()
        await start(callback.message)
        return
    if callback.data == "select_all":
        await state.update_data(select=[int(session.me.id) for session in ses])
        log_msg = f"–í—ã–±—Ä–∞–Ω—ã –≤—Å–µ –∞–∫–∫–∞—É–Ω—Ç—ã –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}: {len(ses)}"
        rootLogger.info(log_msg)
        write_daily_log(log_msg)
        await state.set_state(AddPrivateChannelState.confirm)
        await callback.message.edit_text("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞:", reply_markup=atypes.InlineKeyboardMarkup(inline_keyboard=[
            [atypes.InlineKeyboardButton(text="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_create")],
            [atypes.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_select")]
        ]))
    elif callback.data == "select_selective":
        await state.update_data(select=[])
        builder = InlineKeyboardBuilder()
        for session in ses:
            me = session.me
            builder.row(atypes.InlineKeyboardButton(
                text=f"‚ùå {me.first_name}{' ' + me.last_name if me.last_name else ''} ({'@' + me.username if me.username else '+' + me.phone_number} {me.id})",
                callback_data=f"select_channel_{me.id}"))
        builder.row(atypes.InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="select_channel_done"))
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã:", reply_markup=builder.as_markup())
    await callback.answer()
@dp.callback_query(AddPrivateChannelState.select, (F.from_user.id == owner_id) & (F.data.startswith("select_channel_")))
async def select_channel_specific(callback: atypes.CallbackQuery, state: FSMContext):
    global sessions, selected_company
    data = await state.get_data()
    if callback.data == "select_channel_done":
        select = data.get("select", [])
        if not select:
            await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∞–∫–∫–∞—É–Ω—Ç.")
            return
        await state.set_state(AddPrivateChannelState.confirm)
        await callback.message.edit_text("–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞:", reply_markup=atypes.InlineKeyboardMarkup(inline_keyboard=[
            [atypes.InlineKeyboardButton(text="–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm_create")],
            [atypes.InlineKeyboardButton(text="–ù–∞–∑–∞–¥", callback_data="back_to_select")]
        ]))
        return
    session_id = int(callback.data.split("_")[-1])
    select = data.get("select", [])
    if session_id in select:
        select.remove(session_id)
    else:
        select.append(session_id)
    await state.update_data(select=select)
    ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
    builder = InlineKeyboardBuilder()
    for session in ses:
        me = session.me
        is_selected = int(me.id) in data.get("select", [])
        builder.row(atypes.InlineKeyboardButton(
            text=f"{'‚úÖ' if is_selected else '‚ùå'} {me.first_name}{' ' + me.last_name if me.last_name else ''} ({'@' + me.username if me.username else '+' + me.phone_number} {me.id})",
            callback_data=f"select_channel_{me.id}"))
    builder.row(atypes.InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="select_channel_done"))
    await callback.message.edit_reply_markup(reply_markup=builder.as_markup())
    await callback.answer()
@dp.callback_query(AddPrivateChannelState.confirm, (F.from_user.id == owner_id) & (F.data == "confirm_create"))
async def confirm_create_channel(callback: atypes.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    await create_channel_for_accounts(data, callback.message, state)
@dp.callback_query(AddPrivateChannelState.confirm, (F.from_user.id == owner_id) & (F.data == "back_to_select"))
async def back_to_select(callback: atypes.CallbackQuery, state: FSMContext):
    await state.set_state(AddPrivateChannelState.select)
    ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç—ã:", reply_markup=kb_all_or_select)
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data.in_({"change_fname", "change_bio", "change_lname", "change_avatar", "delete_avatar", "change_story_reactions"})))
async def change(callback: atypes.CallbackQuery, state: FSMContext):
    callback_data = callback.data
    change_type = callback_data[7:] if callback_data.startswith("change_") else callback_data
    rootLogger.info(f"–í—ã–±—Ä–∞–Ω —Ç–∏–ø –∏–∑–º–µ–Ω–µ–Ω–∏—è: {change_type}")
    await state.update_data(change=change_type)
    if change_type == "fname":
        await state.set_state(ChangeState.value)
        await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –∏–º—è:")
    elif change_type == "lname":
        await state.set_state(ChangeState.value)
        await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—É—é —Ñ–∞–º–∏–ª–∏—é:")
    elif change_type == "avatar":
        await state.set_state(ChangeState.value)
        await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ —Ñ–æ—Ç–æ:")
    elif change_type == "delete_avatar":
        await state.set_state(ChangeState.select)
        await callback.message.edit_text("–ö –∫–∞–∫–∏–º –∞–∫–∫–∞—É–Ω—Ç–∞–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ?", reply_markup=kb_all_or_select)
    elif change_type == "bio":
        await state.set_state(ChangeState.value)
        await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤–æ–µ –±–∏–æ:")
    elif change_type == "story_reactions":
        await state.set_state(ChangeState.select)
        await callback.message.edit_text("–ö –∫–∞–∫–∏–º –∞–∫–∫–∞—É–Ω—Ç–∞–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏?", reply_markup=kb_all_or_select)
    await callback.answer()
@dp.message((F.from_user.id == owner_id) & (F.text == "/cancel"))
async def cancel(message: atypes.Message, state: FSMContext):
    if await state.get_state() is not None:
        await state.clear()
        await message.reply("–û—Ç–º–µ–Ω–µ–Ω–æ.")
    await start(message)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "change_company"))
async def change_company(callback: atypes.CallbackQuery):
    global selected_company
    selected_company = None
    kb_companies = atypes.InlineKeyboardMarkup(inline_keyboard=list(
        map(lambda x: [atypes.InlineKeyboardButton(text=x, callback_data="sel_company_" + x)],
            listdir("./companies"))
        ) + [[atypes.InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –∫–æ–º–ø–∞–Ω–∏—é", callback_data="create_company")]])
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é:", reply_markup=kb_companies)
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "filter_keywords"))
async def start_filter_keywords(callback: atypes.CallbackQuery, state: FSMContext):
    if not selected_company:
        await callback.message.edit_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é.")
        await callback.answer()
        return
    await state.set_state(KeywordsState.waiting_keywords)
    await callback.message.edit_text("–í–≤–µ–¥–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (e.g., '—Å–ª–æ–≤–æ1,—Å–ª–æ–≤–æ2') –∏–ª–∏ –ø–æ —Å—Ç—Ä–æ–∫–µ. –î–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è ‚Äî '–æ—Ç–º–µ–Ω–∞':")
    await callback.answer()
@dp.message(KeywordsState.waiting_keywords, (F.from_user.id == owner_id))
async def set_keywords(message: atypes.Message, state: FSMContext):
    if message.text.lower().strip() == '–æ—Ç–º–µ–Ω–∞':
        company_configs[selected_company]['keywords'] = []
        await message.reply("–§–∏–ª—å—Ç—Ä –æ—Ç–∫–ª—é—á—ë–Ω (–ª–∞–π–∫–∞–µ–º –≤—Å–µ—Ö).")
    else:
        keywords = [kw.strip().lower() for kw in message.text.replace(',', '\n').split('\n') if kw.strip()]
        company_configs[selected_company]['keywords'] = keywords
        await message.reply(f"–§–∏–ª—å—Ç—Ä —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {', '.join(keywords)} (–ª–∞–π–∫–∞–µ–º —Ç–æ–ª—å–∫–æ —Å —ç—Ç–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ –≤ –∏–º–µ–Ω–∏/–±–∏–æ).")
    # –°–æ—Ö—Ä–∞–Ω–∏ config
    config_file = f"./companies/{selected_company}/config.json"
    with open(config_file, "w", encoding='utf-8') as f:
        json.dump(company_configs[selected_company], f, ensure_ascii=False)
    rootLogger.info(f"–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è {selected_company}: {keywords}")
    write_daily_log(f"–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è {selected_company}: {keywords}")
    await state.clear()
    await start(message)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "refresh_sessions"))
async def refresh_sessions(callback: atypes.CallbackQuery):
    if not selected_company:
        await callback.message.edit_text("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é.")
        await callback.answer()
        return
    await callback.message.edit_text("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π...")
    await callback.answer()
    old_sessions_count = len(sessions)
    new_sessions = []
    for company in [selected_company]: # –¢–æ–ª—å–∫–æ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏
        sessions_dir = f"./companies/{company}/sessions"
        if os.path.exists(sessions_dir):
            session_files = [f for f in os.listdir(sessions_dir) if f.endswith('.session')]
            for filename in session_files:
                full_path = os.path.join(sessions_dir, filename)
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –≤ sessions
                if not any(s.filename == filename and s.company == company for s in sessions):
                    client = make_client(full_path)
                    session = Session(client, filename, company)
                    new_sessions.append(session)
    if not new_sessions:
        await callback.message.edit_text("–ù–µ—Ç –Ω–æ–≤—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.")
        await start(callback.message)
        return
    # –ê–∫—Ç–∏–≤–∞—Ü–∏—è –Ω–æ–≤—ã—Ö
    tasks = [activate_session(session) for session in new_sessions]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    added_count = sum(1 for result in results if result is True)
    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —É—Å–ø–µ—à–Ω—ã–µ
    for session, result in zip(new_sessions, results):
        if result is True and session not in sessions:
            sessions.append(session)
    log_msg = f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏–π –¥–ª—è {selected_company}: –¥–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –Ω–æ–≤—ã—Ö –∏–∑ {len(new_sessions)}."
    rootLogger.info(log_msg)
    write_daily_log(log_msg)
    await bot.send_message(chat_id, log_msg)
    await callback.message.edit_text(log_msg)
    await start(callback.message)
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "change_sessions"))
async def change_sessions(callback: atypes.CallbackQuery):
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–∏–∂–µ:", reply_markup=kb_change_settings)
    await callback.answer()
@dp.message(ChangeState.value, (F.from_user.id == owner_id) & (F.photo | F.text))
async def set_val(message: atypes.Message, state: FSMContext):
    data = await state.get_data()
    change = data["change"]
    if change == "avatar":
        if message.photo:
            best_photo = sorted(message.photo, key=lambda x: x.file_size, reverse=True)[0]
            file = await bot.get_file(best_photo.file_id)
            photo_io = await bot.download_file(file.file_path)
            photo_bytes = photo_io.getvalue()
            await state.update_data(value=photo_bytes)
            await state.set_state(ChangeState.select)
            await message.reply("–ö –∫–∞–∫–∏–º –∞–∫–∫–∞—É–Ω—Ç–∞–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å?", reply_markup=kb_all_or_select)
        else:
            await message.reply("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ '–æ—Ç–º–µ–Ω–∞'")
    elif change in ["fname", "lname", "bio"]:
        await state.update_data(value=message.text)
        await state.set_state(ChangeState.select)
        await message.reply("–ö –∫–∞–∫–∏–º –∞–∫–∫–∞—É–Ω—Ç–∞–º –ø—Ä–∏–º–µ–Ω–∏—Ç—å?", reply_markup=kb_all_or_select)
@dp.message((F.from_user.id == owner_id) & (F.text == "/blacklist"))
async def blacklist_command(message: atypes.Message, state: FSMContext):
    # –°–æ–∑–¥–∞—ë–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–æ–º–ø–∞–Ω–∏–∏
    kb_companies = atypes.InlineKeyboardMarkup(inline_keyboard=list(
        map(lambda x: [atypes.InlineKeyboardButton(text=x, callback_data="blacklist_company_" + x)],
            listdir("./companies"))
    ) + [[atypes.InlineKeyboardButton(text="–û—Ç–º–µ–Ω–∞", callback_data="blacklist_cancel")]])
   
    await message.reply("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫:", reply_markup=kb_companies)
    await state.set_state(BlacklistState.company)
@dp.callback_query(BlacklistState.company, (F.from_user.id == owner_id) & (F.data.startswith("blacklist_company_")))
async def process_company_selection(callback: atypes.CallbackQuery, state: FSMContext):
    company = callback.data.replace("blacklist_company_", "")
    await state.update_data(company=company)
    await callback.message.edit_text("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–ø–∏—Å–æ–∫ —é–∑–µ—Ä–Ω–µ–π–º–æ–≤ –≤ —Å—Ç–æ–ª–±–∏–∫ (–Ω–∞–ø—Ä–∏–º–µ—Ä:\nuser1\nuser2\nuser3):", reply_markup=None)
    await state.set_state(BlacklistState.usernames)
    await callback.answer()
@dp.callback_query(BlacklistState.company, (F.from_user.id == owner_id) & (F.data == "blacklist_cancel"))
async def cancel_blacklist(callback: atypes.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=None)
    await callback.answer()
    await start(callback.message)
@dp.message(BlacklistState.usernames, (F.from_user.id == owner_id))
async def process_usernames(message: atypes.Message, state: FSMContext):
    data = await state.get_data()
    company = data['company']
    usernames = message.text.strip().split('\n')
   
    cursor = conn.cursor()
    added_count = 0
   
    for username in usernames:
        username = username.strip().lstrip('@') # –£–±–∏—Ä–∞–µ–º @ –∏ –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
        if not username:
            continue
       
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫, –µ—Å–ª–∏ –µ—â—ë –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        cursor.execute("""
            INSERT OR IGNORE INTO blacklist (username, company)
            VALUES (?, ?)
        """, (username, company))
        if cursor.rowcount > 0:
            added_count += 1
            rootLogger.info(f"–î–æ–±–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å @{username} –≤ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ {company}")
   
    conn.commit()
    await message.reply(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ —á—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∫–æ–º–ø–∞–Ω–∏–∏ {company}.")
    await state.clear()
    await start(message)
@dp.message((F.from_user.id == owner_id) & (F.text == "/view_blacklist"))
async def view_blacklist(message: atypes.Message):
    if not selected_company:
        await message.reply("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏—é.")
        return
   
    cursor = conn.cursor()
    cursor.execute("SELECT username FROM blacklist WHERE company = ?", (selected_company,))
    blacklisted_users = cursor.fetchall()
   
    if not blacklisted_users:
        await message.reply(f"–ß—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company} –ø—É—Å—Ç.")
    else:
        users_list = "\n".join([f"@{user[0]}" for user in blacklisted_users])
        await message.reply(f"–ß—ë—Ä–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∫–æ–º–ø–∞–Ω–∏–∏ {selected_company}:\n{users_list}")
   
    await start(message)
@dp.callback_query(ChangeState.select, (F.from_user.id == owner_id) & (F.data.startswith("select_")))
async def sel_acc(callback: atypes.CallbackQuery, state: FSMContext):
    global sessions
    try:
        ses = list(filter(lambda x: x.me is not None and x.company == selected_company, sessions))
        if not ses:
            await callback.message.edit_text("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π –¥–ª—è —ç—Ç–æ–π –∫–æ–º–ø–∞–Ω–∏–∏.")
            await state.clear()
            await start(callback.message)
            return
        data = await state.get_data()
        select = data.get("select", [])
        if callback.data == "select_done":
            if not select:
                await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∞–∫–∫–∞—É–Ω—Ç.")
                return
            await apply_data(callback, state)
            return
        elif callback.data == "select_all":
            await state.update_data(select=[int(session.me.id) for session in ses])
            await apply_data(callback, state)
            return
        elif callback.data == "select_selective":
            await sel_accs(callback, state)
            return
        session_id = int(callback.data[7:])
        if session_id in select:
            select.remove(session_id)
        else:
            select.append(session_id)
        await state.update_data(select=select)
        builder = InlineKeyboardBuilder()
        for session in ses:
            me = session.me
            is_selected = int(me.id) in select
            builder.row(atypes.InlineKeyboardButton(
                text=f"{'‚úÖ' if is_selected else '‚ùå'} {me.first_name}{' ' + me.last_name if me.last_name else ''} ({'@' + me.username if me.username else '+' + me.phone_number if me.phone_number else str(me.id)} {me.id})",
                callback_data=f"select_{me.id}"))
        builder.row(atypes.InlineKeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="select_done"))
        builder.row(atypes.InlineKeyboardButton(text="–í—ã–±—Ä–∞—Ç—å –≤—Å–µ", callback_data="select_all"))
        builder.row(atypes.InlineKeyboardButton(text="–í—ã–±—Ä–∞–Ω–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã", callback_data="select_selective"))
        await callback.message.edit_reply_markup(reply_markup=builder.as_markup())
    except Exception as e:
        log_msg = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ sel_acc: {str(e)}"
        rootLogger.error(log_msg)
        write_daily_log(log_msg)
        await callback.message.edit_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞.")
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "toggle_companies"))
async def toggle_companies(callback: atypes.CallbackQuery, state: FSMContext):
    await state.set_state(CompanyToggleState.selected_companies)
    await state.update_data(selected_companies=list(company_active.keys()))
    keyboard = []
    for company in company_configs.keys():
        ses = [s for s in sessions if s.company == company and s.me]
        is_liking = company_active.get(company, False)
        status = "‚úÖ" if is_liking else "‚ùå"
        button_text = f"{status} {company}"
        button = InlineKeyboardButton(
            text=button_text,
            callback_data=CompanyToggleCallback(action="toggle", company_name=company).pack()
        )
        keyboard.append([button])
    keyboard.append([InlineKeyboardButton(text="–ì–æ—Ç–æ–≤–æ", callback_data="done_toggling")])
    kb = atypes.InlineKeyboardMarkup(inline_keyboard=keyboard)
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏–∏ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏/–¥–µ–∞–∫—Ç–∏–≤–∞—Ü–∏–∏:", reply_markup=kb)
    await callback.answer()
@dp.callback_query((F.from_user.id == owner_id) & (F.data == "setup_params"))
async def setup_params(callback: atypes.CallbackQuery, state: FSMContext):
    await state.set_state(SetupParamsState.waiting_value)
    await state.update_data(selected_companies=[], current_index=0, current_company=None, current_param=None)
    builder = InlineKeyboardBuilder()
    for company in sorted(company_configs.keys()):
        builder.row(InlineKeyboardButton(
            text=f"–ù–µ –≤—ã–±—Ä–∞–Ω–æ {company}",
            callback_data=f"select_setup_{company}"
        ))
    builder.row(InlineKeyboardButton(text="–ì–æ—Ç–æ–≤–æ", callback_data="setup_done"))
    await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–ø–∞–Ω–∏–∏ –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤:", reply_markup=builder.as_markup())
    await callback.answer()
@dp.callback_query(SetupParamsState.waiting_value, (F.from_user.id == owner_id) & (F.data.startswith("select_setup_")))
async def select_setup_company(callback: atypes.CallbackQuery, state: FSMContext):
    company = callback.data.replace("select_setup_", "")
    data = await state.get_data()
    selected = data.get("selected_companies", [])
    if company in selected:
        selected.remove(company)
    else:
        selected.append(company)
    await state.update_data(selected_companies=selected)
    builder = InlineKeyboardBuilder()
    for comp in sorted(company_configs.keys()):
        is_sel = comp in selected
        builder.row(InlineKeyboardButton(
            text=f"{'–í—ã–±—Ä–∞–Ω–æ' if is_sel else '–ù–µ –≤—ã–±—Ä–∞–Ω–æ'} {comp}",
            callback_data=f"select_setup_{comp}"
        ))
    builder.row(InlineKeyboardButton(text="–ì–æ—Ç–æ–≤–æ", callback_data="setup_done"))
    await callback.message.edit_reply_markup(reply_markup=builder.as_markup())
    await callback.answer()
@dp.callback_query(SetupParamsState.waiting_value, (F.from_user.id == owner_id) & (F.data == "setup_done"))
async def setup_done(callback: atypes.CallbackQuery, state: FSMContext):
    data = await state.get_data()
    selected = data.get("selected_companies", [])
    if not selected:
        await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –∫–æ–º–ø–∞–Ω–∏—é.")
        await callback.answer()
        return
    await state.update_data(current_index=0)
    current_company = selected[0]
    await state.update_data(current_company=current_company, current_param="like_probability")
    await callback.message.edit_text(
        f"–î–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ '{current_company}':\n"
        f"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ª–∞–π–∫–∞ (0-100, –Ω–∞–ø—Ä–∏–º–µ—Ä 80 –¥–ª—è 80%):"
    )
    await callback.answer()
@dp.message(SetupParamsState.waiting_value, (F.from_user.id == owner_id) & F.text)
async def handle_setup_value(message: atypes.Message, state: FSMContext):
    data = await state.get_data()
    current_param = data.get("current_param")
    current_company = data.get("current_company")
    selected = data.get("selected_companies", [])
    current_index = data.get("current_index", 0)
    try:
        value = float(message.text.strip()) if current_param in ["story_delay_min", "story_delay_max"] else int(message.text.strip())
        if current_param == "like_probability":
            value = float(message.text.strip())
            if not 0 <= value <= 100:
                raise ValueError("–î–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 0 –¥–æ 100")
            company_configs[current_company]["like_probability"] = value / 100
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º config —Å—Ä–∞–∑—É
            config_file = f"./companies/{current_company}/config.json"
            with open(config_file, "w", encoding='utf-8') as f:
                json.dump(company_configs[current_company], f, ensure_ascii=False)
            rootLogger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä {current_param} –¥–ª—è {current_company}: {value / 100}")
            await message.reply(
                f"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ª–∞–π–∫–∞ –¥–ª—è '{current_company}' —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ {int(value)}%.\n"
                f"–¢–µ–ø–µ—Ä—å –∫–æ–ª-–≤–æ –∞–∫–∫–æ–≤ –Ω–∞ –∫–∞–Ω–∞–ª (—Ü–µ–ª–æ–µ >=1):"
            )
            await state.update_data(current_param="accounts_per_channel")
        elif current_param == "accounts_per_channel":
            if value < 1:
                raise ValueError("–î–æ–ª–∂–Ω–æ –±—ã—Ç—å >=1")
            company_configs[current_company]["accounts_per_channel"] = value
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º config
            config_file = f"./companies/{current_company}/config.json"
            with open(config_file, "w", encoding='utf-8') as f:
                json.dump(company_configs[current_company], f, ensure_ascii=False)
            rootLogger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä {current_param} –¥–ª—è {current_company}: {value}")
            await message.reply(
                f"–ö–æ–ª-–≤–æ –∞–∫–∫–æ–≤ –Ω–∞ –∫–∞–Ω–∞–ª –¥–ª—è '{current_company}' = {value}.\n"
                f"–¢–µ–ø–µ—Ä—å –º–∏–Ω. –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å—Ç–æ—Ä–∏—Å (—Å–µ–∫, float >=0.5):"
            )
            await state.update_data(current_param="story_delay_min")
        elif current_param == "story_delay_min":
            if value < 0.5:
                raise ValueError("–î–æ–ª–∂–Ω–æ –±—ã—Ç—å >=0.5")
            company_configs[current_company]["story_delay_min"] = value
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º config
            config_file = f"./companies/{current_company}/config.json"
            with open(config_file, "w", encoding='utf-8') as f:
                json.dump(company_configs[current_company], f, ensure_ascii=False)
            rootLogger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä {current_param} –¥–ª—è {current_company}: {value}")
            await message.reply(
                f"–ú–∏–Ω. –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å—Ç–æ—Ä–∏—Å –¥–ª—è '{current_company}' = {value}—Å.\n"
                f"–ú–∞–∫—Å. –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å—Ç–æ—Ä–∏—Å (—Å–µ–∫, float > min):"
            )
            await state.update_data(current_param="story_delay_max")
        elif current_param == "story_delay_max":
            story_delay_min = company_configs[current_company].get('story_delay_min', 1.0)
            if value <= story_delay_min:
                raise ValueError(f"–î–æ–ª–∂–Ω–æ –±—ã—Ç—å > {story_delay_min}")
            company_configs[current_company]["story_delay_max"] = value
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º config
            config_file = f"./companies/{current_company}/config.json"
            with open(config_file, "w", encoding='utf-8') as f:
                json.dump(company_configs[current_company], f, ensure_ascii=False)
            rootLogger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä {current_param} –¥–ª—è {current_company}: {value}")
            await message.reply(
                f"–ú–∞–∫—Å. –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å—Ç–æ—Ä–∏—Å –¥–ª—è '{current_company}' = {value}—Å.\n"
                f"–õ–∞–π–∫–æ–≤ –¥–æ –ø–µ—Ä–µ—Ä—ã–≤–∞ (—Ü–µ–ª–æ–µ >=10):"
            )
            await state.update_data(current_param="likes_per_break")
        elif current_param == "likes_per_break":
            if value < 10:
                raise ValueError("–î–æ–ª–∂–Ω–æ –±—ã—Ç—å >=10")
            company_configs[current_company]["likes_per_break"] = value
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º config
            config_file = f"./companies/{current_company}/config.json"
            with open(config_file, "w", encoding='utf-8') as f:
                json.dump(company_configs[current_company], f, ensure_ascii=False)
            rootLogger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä {current_param} –¥–ª—è {current_company}: {value}")
            await message.reply(
                f"–õ–∞–π–∫–æ–≤ –¥–æ –ø–µ—Ä–µ—Ä—ã–≤–∞ –¥–ª—è '{current_company}' = {value}.\n"
                f"–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–µ—Ä–µ—Ä—ã–≤–∞ (—Å–µ–∫, —Ü–µ–ª–æ–µ >=30):"
            )
            await state.update_data(current_param="break_seconds")
        elif current_param == "break_seconds":
            if value < 30:
                raise ValueError("–î–æ–ª–∂–Ω–æ –±—ã—Ç—å >=30")
            company_configs[current_company]["break_seconds"] = value
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º config
            config_file = f"./companies/{current_company}/config.json"
            with open(config_file, "w", encoding='utf-8') as f:
                json.dump(company_configs[current_company], f, ensure_ascii=False)
            rootLogger.info(f"–û–±–Ω–æ–≤–ª—ë–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä {current_param} –¥–ª—è {current_company}: {value}")
            await message.reply(
                f"–ü–µ—Ä–µ—Ä—ã–≤ –ø–æ—Å–ª–µ {company_configs[current_company]['likes_per_break']} –ª–∞–π–∫–æ–≤ = {value}—Å.\n"
                f"–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è '{current_company}' –∑–∞–≤–µ—Ä—à–µ–Ω—ã."
            )
            current_index += 1
            if current_index < len(selected):
                next_company = selected[current_index]
                await state.update_data(current_index=current_index, current_company=next_company, current_param="like_probability")
                await message.reply(
                    f"\n–î–ª—è –∫–æ–º–ø–∞–Ω–∏–∏ '{next_company}':\n"
                    f"–í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ª–∞–π–∫–∞ (0-100):"
                )
            else:
                await state.clear()
                await message.reply("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –≤—Å–µ—Ö –∫–æ–º–ø–∞–Ω–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω—ã!")
                await start(message)
                return
    except ValueError as e:
        await message.reply(f"–û—à–∏–±–∫–∞: {str(e)}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return
try:
    asyncio.run(main())
except KeyboardInterrupt:
    pass

